// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_io_uring_setup
#define __NR_io_uring_setup 425
#endif

#define SIZEOF_IO_URING_SQE 64
#define SIZEOF_IO_URING_CQE 16
#define SQ_HEAD_OFFSET 0
#define SQ_TAIL_OFFSET 64
#define SQ_RING_MASK_OFFSET 256
#define SQ_RING_ENTRIES_OFFSET 264
#define SQ_FLAGS_OFFSET 276
#define SQ_DROPPED_OFFSET 272
#define CQ_HEAD_OFFSET 128
#define CQ_TAIL_OFFSET 192
#define CQ_RING_MASK_OFFSET 260
#define CQ_RING_ENTRIES_OFFSET 268
#define CQ_RING_OVERFLOW_OFFSET 284
#define CQ_FLAGS_OFFSET 280
#define CQ_CQES_OFFSET 320

struct io_sqring_offsets {
	uint32_t head;
	uint32_t tail;
	uint32_t ring_mask;
	uint32_t ring_entries;
	uint32_t flags;
	uint32_t dropped;
	uint32_t array;
	uint32_t resv1;
	uint64_t resv2;
};

struct io_cqring_offsets {
	uint32_t head;
	uint32_t tail;
	uint32_t ring_mask;
	uint32_t ring_entries;
	uint32_t overflow;
	uint32_t cqes;
	uint64_t resv[2];
};

struct io_uring_params {
	uint32_t sq_entries;
	uint32_t cq_entries;
	uint32_t flags;
	uint32_t sq_thread_cpu;
	uint32_t sq_thread_idle;
	uint32_t features;
	uint32_t resv[4];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

#define IORING_OFF_SQ_RING 0
#define IORING_OFF_SQES 0x10000000ULL

static long syz_io_uring_setup(volatile long a0, volatile long a1, volatile long a2, volatile long a3, volatile long a4, volatile long a5)
{
	uint32_t entries = (uint32_t)a0;
	struct io_uring_params* setup_params = (struct io_uring_params*)a1;
	void* vma1 = (void*)a2;
	void* vma2 = (void*)a3;
	void** ring_ptr_out = (void**)a4;
	void** sqes_ptr_out = (void**)a5;
	uint32_t fd_io_uring = syscall(__NR_io_uring_setup, entries, setup_params);
	uint32_t sq_ring_sz = setup_params->sq_off.array + setup_params->sq_entries * sizeof(uint32_t);
	uint32_t cq_ring_sz = setup_params->cq_off.cqes + setup_params->cq_entries * SIZEOF_IO_URING_CQE;
	uint32_t ring_sz = sq_ring_sz > cq_ring_sz ? sq_ring_sz : cq_ring_sz;
	*ring_ptr_out = mmap(vma1, ring_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE | MAP_FIXED, fd_io_uring, IORING_OFF_SQ_RING);
	uint32_t sqes_sz = setup_params->sq_entries * SIZEOF_IO_URING_SQE;
	*sqes_ptr_out = mmap(vma2, sqes_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE | MAP_FIXED, fd_io_uring, IORING_OFF_SQES);
	return fd_io_uring;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
*(uint32_t*)0x20000504 = 0x8eff;
*(uint32_t*)0x20000508 = 0;
*(uint32_t*)0x2000050c = 3;
*(uint32_t*)0x20000510 = 0x326;
*(uint32_t*)0x20000518 = -1;
memset((void*)0x2000051c, 0, 12);
	res = -1;
res = syz_io_uring_setup(0, 0x20000500, 0x20c00000, 0x20ee3000, 0x20000580, 0x200005c0);
	if (res != -1)
		r[0] = res;
*(uint32_t*)0x20000604 = 0;
*(uint32_t*)0x20000608 = 0;
*(uint32_t*)0x2000060c = 3;
*(uint32_t*)0x20000610 = 0x32a;
*(uint32_t*)0x20000618 = r[0];
memset((void*)0x2000061c, 0, 12);
syz_io_uring_setup(0x1063, 0x20000600, 0x20ffd000, 0x20d17000, 0x20000680, 0x200006c0);
*(uint32_t*)0x20000044 = 0;
*(uint32_t*)0x20000048 = 0;
*(uint32_t*)0x2000004c = 0;
*(uint32_t*)0x20000050 = 0x1d;
*(uint32_t*)0x20000058 = -1;
memset((void*)0x2000005c, 0, 12);
	syscall(__NR_io_uring_setup, 0x2438, 0x20000040ul);
memcpy((void*)0x20000140, "\xf7\xd5\x51\xee\xa0\x6a\xc2\x1e\x9e\xc1\x12\x60\xff\xc6\x5e\xf4\xa2\x94\x07\x70\x8d\xa9\xf7\x4a\x25\x76\xd5\xff\x33\xb2\x0d\x41\x5e\x59\x7a\x76\xd3\x45\xae\xa4\xa8\xcf\xf6\x26\x66\x66\xb1\x29\xb4\xcd\x74\xaa\x47\x47\xfc\xe8\x21\x05\x07\x0c\xc9\x40\x1c\x74\xdc\xad\x3d\x1f\x5d\x5f\x0d\xc6\x69\x49\x88\xe1\x9f\x1a\x85\x83\x06\xd2\xfd\x74\x65\x48\x09\x56\x3d\xde\x15\xc3\xda\x1e\xe8\x2d\xed\xf7\xaa\x41\xe3\x46\xc3\xea\x61\x89\x02\x71\x72\x10\xab\x4f\xcf\xe1\x08\x96\x3a\x05\x6e\xc2\x79\xb8\x48\x2b\x8e\x56\x11\x90\xcd\x18\x6a\x00\xff\x7d\x08\x60\xa0\x68\x38\xb4\x33\x93\x39\x91\xa0\xeb\xfb\xd8\x8e\x16\x61\xe6\xd0\x86\x3e\x87\x85\xdd\x78\x3b\x63\xd7\xaa\xe3\x48\x8b\x8d\x4c\x03\x96\x34\x1d\x56\x1f\xa4\x76\x45\x2f\x72", 179);
syz_clone(0x40800400, 0x20000140, 0xb3, 0x20000000, 0x20000200, 0);
memcpy((void*)0x20000280, "\xed\x9a\x89\x21\x6e\x47\xf9\x10\x0f\xef\x55\xf7\xa0\x2e\x11\x4c\x72\xa5\xbd\x84\xde\xde\x43\xcf\xd8\x1c\x08\xe2\xb4\xe0\x64\xe8\xb0\xc0\x5e\x85\x63\x63\x05\x04\x76\x2e\x81\xc4\x8d\x1b\xf7\xf6\x23\xfe\x7c\xa6\xa9\x66\xa1\xa8\x3a\xb4\x35\x86\xa8\x19\xff\x77\xdd\xe8\xe5\xbf\xb8\x77\x98\xd1\x68\xf7\x66\xef\x3f\x93\xdf\x7e\x6c\xb9\x4f\x9a\x1f\xfd\x7e\x4e\xa9\x85\xb4\xa5\x7d\x33\x93\x89\x91\x7f\x9d\x11\xfe\xc5\xed\x99\xef\xfc\x49\x0b\x2d\x61\xb8\xa1\x97\xaa\x6b\xf3\xb6\x81\xfc\x1c\xb4\x48\x82\x86\x06\x68\xe5\xf4\x98\x41\x3a\xa1\x9e\xb1\xa1\x77\x1e\x42\x96\x81\xe2\x40\xa7\xd1\xf6\x24\xca\x1a\xa3\xac\xd6\x19\x7a\x1b\x10\xb3\x10\xeb\x17\xea\x5c\x39\x4b\x04\xa9\x71\xc3\x87\xe5\x17\x9a\x00\xb3\x71\x07\x8a\x44\x15\x84\x32\x37\x78\x1f\x65\xa2\xdb\xef\xbf\x4b", 189);
syz_clone(0x10000, 0x20000280, 0xbd, 0x20000380, 0x200003c0, 0);
*(uint32_t*)0x200004c0 = 0;
	syscall(__NR_ioctl, -1, 0xc00c620f, 0x200004c0ul);
	return 0;
}
