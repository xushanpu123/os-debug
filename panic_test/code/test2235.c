// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif
#ifndef __NR_statx
#define __NR_statx 332
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

uint64_t r[2] = {0xffffffffffffffff, 0x0};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
memcpy((void*)0x200001c0, "./file0\000", 8);
	res = syscall(__NR_open, 0x200001c0ul, 0x88140ul, 0ul);
	if (res != -1)
		r[0] = res;
memcpy((void*)0x20000640, "./file0\000", 8);
	res = syscall(__NR_statx, 0xffffff9c, 0x20000640ul, 0ul, 0x40ul, 0x20000680ul);
	if (res != -1)
r[1] = *(uint32_t*)0x20000694;
memcpy((void*)0x20000040, "./file0\000", 8);
*(uint64_t*)0x20000540 = 0x20000140;
memcpy((void*)0x20000140, "\xc5\x80\xc5\x9f\xa7", 5);
*(uint64_t*)0x20000548 = 5;
*(uint64_t*)0x20000550 = 0;
*(uint64_t*)0x20000558 = 0x20000280;
memcpy((void*)0x20000280, "\xc6\x49\x3d", 3);
*(uint64_t*)0x20000560 = 3;
*(uint64_t*)0x20000568 = 5;
*(uint64_t*)0x20000570 = 0x20000340;
memset((void*)0x20000340, 190, 1);
*(uint64_t*)0x20000578 = 1;
*(uint64_t*)0x20000580 = 8;
*(uint64_t*)0x20000588 = 0x20000180;
memcpy((void*)0x20000180, "\xa5\x66\x69\x6e\x6f\xb1\xaa\x9c\x16\x4c\x7d\x6e\x30\xe7\x9d\xbe\x03\xbe\x96\xf4\xd6\xbf", 22);
*(uint64_t*)0x20000590 = 0x16;
*(uint64_t*)0x20000598 = 9;
*(uint64_t*)0x200005a0 = 0x200003c0;
memcpy((void*)0x200003c0, "\xed\x98\x22\xad\x09\x5c\xc6\x2c\x45\xfd\x1f\x7a\x2d\xc2\xbd\x59\xe8\x37\x00\x49\xf8\xe5\xee\x93\xb6\x6b\x5e\x43\xff\x59\x68\xfa\x0e\xeb\x60\xb5\xaa\xf5\x8a\x88\x2a\xa7\x7d\xd0\x16\x6b\x11\xd1\xe4\xe0\x46\xa8\x51\x7f\xd3\x32\xb5\x34\xc3\xc8\x22\x53\xad\x26\x7d\x13\x1b\xac\x15\x45\xe7\x44\xcd\x97\x6d\x1e\x90\x86\xa5\xdd\xb4\xae\xb5\x33\x40\xb1\x5c\x95\x0d\xba\xd1\x86\x63\x7b\xff\x56\xeb\xe7\x24\xfc\x97\x0d\x1d\x87\x4a\x2c\xad\x2d\x00\x00\x0c\x0a\xf3\x2c\x09\x25\x91\xcb\x10\x8c\xf9\x7b\x8a\xb4\x8f\x02\x34\x34\xd4\x60\x01\x64\xe9\x3f\x9a", 135);
*(uint64_t*)0x200005a8 = 0x87;
*(uint64_t*)0x200005b0 = 0x1f;
memcpy((void*)0x20000780, "dioread_lock", 12);
*(uint8_t*)0x2000078c = 0x2c;
memcpy((void*)0x2000078d, "nogrpid", 7);
*(uint8_t*)0x20000794 = 0x2c;
memcpy((void*)0x20000795, "sysvgroups", 10);
*(uint8_t*)0x2000079f = 0x2c;
memcpy((void*)0x200007a0, "abort", 5);
*(uint8_t*)0x200007a5 = 0x2c;
memcpy((void*)0x200007a6, "dioread_lock", 12);
*(uint8_t*)0x200007b2 = 0x2c;
memcpy((void*)0x200007b3, "usrjquota=", 10);
*(uint8_t*)0x200007bd = 0x2c;
memcpy((void*)0x200007be, "min_batch_time", 14);
*(uint8_t*)0x200007cc = 0x3d;
sprintf((char*)0x200007cd, "0x%016llx", (long long)0x100);
*(uint8_t*)0x200007df = 0x2c;
memcpy((void*)0x200007e0, "bsdgroups", 9);
*(uint8_t*)0x200007e9 = 0x2c;
memcpy((void*)0x200007ea, "pcr", 3);
*(uint8_t*)0x200007ed = 0x3d;
sprintf((char*)0x200007ee, "%020llu", (long long)6);
*(uint8_t*)0x20000802 = 0x2c;
memcpy((void*)0x20000803, "smackfstransmute", 16);
*(uint8_t*)0x20000813 = 0x3d;
memcpy((void*)0x20000814, "/\\$#@(", 6);
*(uint8_t*)0x2000081a = 0x2c;
memcpy((void*)0x2000081b, "subj_role", 9);
*(uint8_t*)0x20000824 = 0x3d;
*(uint8_t*)0x20000825 = 0x2c;
memcpy((void*)0x20000826, "fowner>", 7);
sprintf((char*)0x2000082d, "%020llu", (long long)0);
*(uint8_t*)0x20000841 = 0x2c;
memcpy((void*)0x20000842, "uid>", 4);
sprintf((char*)0x20000846, "%020llu", (long long)0);
*(uint8_t*)0x2000085a = 0x2c;
memcpy((void*)0x2000085b, "smackfsfloor", 12);
*(uint8_t*)0x20000867 = 0x3d;
memset((void*)0x20000868, 91, 1);
*(uint8_t*)0x20000869 = 0x2c;
*(uint8_t*)0x2000086a = 0;
syz_mount_image(0, 0x20000040, 0x8100000, 5, 0x20000540, 0x4080, 0x20000780, 0);
memcpy((void*)0x20000000, "nfs\000", 4);
memcpy((void*)0x20000040, "./file0\000", 8);
*(uint64_t*)0x20000200 = 0x20000080;
memcpy((void*)0x20000080, "\x6d\xee\x01\xcc\xa1\x90\x44\x0f\xa3\x3b\xde\x2f\xb8\xc5\xf1\xea\xa8\x84\x63\x98\xd8\x0a\xc7\x0e\x51\xab\x65\x4a\xd5\x81\x4c\x39\x89\x5d\x9b\xc8\xe7\x1b\x4b\x79\x72\x7f\xf4\x90\xbb\xb4\x37\x74\xd8\x97\x63\x1e\xc1\x57\x9b\x6b\xfb\xda\xf3\x5b\xf2\x65\x63\x38\xf1\x7f\xc7\x82\xc8\x73\x43\xc0\x3e\x17\x8a\xa0\x7a\xca\x80\xd0\x4d\xf1\x6a\x1f\xdd\x12\x64\x67\x5c\x6e\x4f\x4b\xc1\x5d\x5c\x9e\x09\xf0\x6a\xd3\x02\x98\x0a\xfe\x05\xcd\xba\x1f\x47\x0d\xa3\xb0\xa4\x6b\x0d\x30", 116);
*(uint64_t*)0x20000208 = 0x74;
*(uint64_t*)0x20000210 = 0x4b;
memcpy((void*)0x20000240, "\'--", 3);
*(uint8_t*)0x20000243 = 0x2c;
memcpy((void*)0x20000244, "^%\265\307(.", 6);
*(uint8_t*)0x2000024a = 0x2c;
memcpy((void*)0x2000024b, "N^.", 3);
*(uint8_t*)0x2000024e = 0x2c;
memcpy((void*)0x2000024f, "})*", 3);
*(uint8_t*)0x20000252 = 0x2c;
memcpy((void*)0x20000253, "*\336@", 3);
*(uint8_t*)0x20000256 = 0x2c;
memcpy((void*)0x20000257, "(}-", 3);
*(uint8_t*)0x2000025a = 0x2c;
memcpy((void*)0x2000025b, "uid<", 4);
sprintf((char*)0x2000025f, "%020llu", (long long)r[1]);
*(uint8_t*)0x20000273 = 0x2c;
memcpy((void*)0x20000274, "subj_role", 9);
*(uint8_t*)0x2000027d = 0x3d;
memset((void*)0x2000027e, 92, 1);
*(uint8_t*)0x2000027f = 0x2c;
memcpy((void*)0x20000280, "obj_type", 8);
*(uint8_t*)0x20000288 = 0x3d;
memcpy((void*)0x20000289, "(^", 2);
*(uint8_t*)0x2000028b = 0x2c;
memcpy((void*)0x2000028c, "euid<", 5);
sprintf((char*)0x20000291, "%020llu", (long long)0);
*(uint8_t*)0x200002a5 = 0x2c;
memcpy((void*)0x200002a6, "defcontext", 10);
*(uint8_t*)0x200002b0 = 0x3d;
memcpy((void*)0x200002b1, "staff_u", 7);
*(uint8_t*)0x200002b8 = 0x2c;
memcpy((void*)0x200002b9, "appraise_type=imasig", 20);
*(uint8_t*)0x200002cd = 0x2c;
*(uint8_t*)0x200002ce = 0;
syz_mount_image(0x20000000, 0x20000040, 0xbf, 1, 0x20000200, 0x4908, 0x20000240, 0);
	syscall(__NR_syncfs, r[0]);
memcpy((void*)0x20000640, "./file0\000", 8);
	syscall(__NR_statx, 0xffffff9c, 0x20000640ul, 0ul, 0ul, 0x20000680ul);
	return 0;
}
