// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/sched.h>

#ifndef __NR_clone3
#define __NR_clone3 435
#endif

#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

#define MAX_CLONE_ARGS_BYTES 256
static long syz_clone3(volatile long a0, volatile long a1)
{
	unsigned long copy_size = a1;
	if (copy_size < sizeof(uint64_t) || copy_size > MAX_CLONE_ARGS_BYTES)
		return -1;
	char clone_args[MAX_CLONE_ARGS_BYTES];
	memcpy(&clone_args, (void*)a0, copy_size);
	uint64_t* flags = (uint64_t*)&clone_args;
	*flags &= ~CLONE_VM;
	return handle_clone_ret((long)syscall(__NR_clone3, &clone_args, copy_size));
}

uint64_t r[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
memset((void*)0x20000000, 0, 64);
*(uint32_t*)0x20000040 = 0;
*(uint32_t*)0x20000044 = 3;
*(uint32_t*)0x20000048 = 0;
memset((void*)0x2000004c, 0, 20);
	syscall(__NR_ioctl, -1, 0xc0603d0f, 0x20000000ul);
	res = syscall(__NR_pipe2, 0x200000c0ul, 0x80ul);
	if (res != -1) {
r[0] = *(uint32_t*)0x200000c0;
r[1] = *(uint32_t*)0x200000c4;
	}
	syscall(__NR_ioctl, -1, 0x43403d05, 0ul);
	syscall(__NR_read, r[0], 0ul, 0ul);
	res = syscall(__NR_pipe2, 0x20000540ul, 0ul);
	if (res != -1) {
r[2] = *(uint32_t*)0x20000540;
r[3] = *(uint32_t*)0x20000544;
	}
memcpy((void*)0x20000580, "devices.deny\000", 13);
	syscall(__NR_openat, r[2], 0x20000580ul, 2ul, 0ul);
*(uint8_t*)0x200005c0 = 0;
*(uint8_t*)0x200005c1 = 0;
*(uint32_t*)0x200005c4 = 7;
*(uint32_t*)0x200005c8 = 0x1e;
*(uint32_t*)0x200005cc = 0x15;
*(uint32_t*)0x200005d0 = 0x1a;
*(uint32_t*)0x200005d4 = 0xb;
*(uint32_t*)0x200005d8 = 6;
*(uint32_t*)0x200005dc = 5;
*(uint32_t*)0x200005e0 = 0xb;
*(uint32_t*)0x200005e4 = 1;
	syscall(__NR_ioctl, r[3], 0x4028700f, 0x200005c0ul);
memcpy((void*)0x20000880, "\x67\x35\x7c\x58\x42\x68\x60\xfb\x70\x41\x58\x90\x75\xdd\xcc\x10\xee\x3d\x09\x49\x10\xf3\xc4\x3a\x8f\x12\xc6\xe1\xd5\x07\xf4\x81\xb4\xc9\x14\x14\xf0\xd5\x21\x04\x94\x5b\x22\x03\x42\xaa\x2a\xe0\x83\x47\xa3\x1b\x9f\x18\x5c\xeb\xe9\x1e\xdd\x50\x2e\xb7\xe3\x41\xe5\x26\x31", 67);
memcpy((void*)0x20000980, "\x79\xca\xae\xc7\x32\xdb\xb9\x1e\x73\x59\x0a\xc3\xbe\x81\xd0\x02\xdb\x6b\xbd\x5a\xf2\xf8\xae\x09\x47\x0e\x6e\xb7\xa0\x29\xf3\x1e\x57\x92\xb0\xcd\x57\xc9\xa9\xef\xdb\x7b\xfe\x35\xa5\x8f\xa1\xbf\x60\x1f\xb0\x7e\xae\x6e\x3d\x81\xab\x8c\x69\xa2\x73\xcd\x78\x9c\x0e\xe8\xd7\x02\x18\x56\xca\x68\xbc\x53\xad\xf0\x00\xbf\x10\x7c\x83\xc3\x63\x8b\x29\x30\x73\xce\x88\x60\x4b\x6c\x40\x32\x00\xef\x57\x1c\x90\x5a\x18\x22\xf6\x4c\x29\x1b\xa4\x02\xc0\x8c\xa3\x67\x72\x43\xf4\xb2\xc6\xec\xcb\xed\x62\x5b\x89\xf0\xa4\x09\x9f\x7f\x79\xfb\x44\xc2\x37\xdc\x25\xc0\x55\x60\xb1\x3c\x4f\x26\x33\xc1\xa5\x83\x2c\xc4\xdd\xce\x05\xa2\xfe\xe8\xea\xd7\xec\xea\xa7\xf9\x0d\xdf\x7c\xd0\x57\x4c\x50\x2d\xff\xe5\x30\xc7\x40\x71\x3f\x44\x49\x6e\xdb\x1a\x8a\x3c\x5a\x97\x4a\x9b\x7b\xd4\xbd\x91\xee\x96\xbb\x36\x21\x01\x45\x14\x53\xb0\x9d\x27\x1f\x4c\xa5\x30\xf3\x83\xcb\x9c\x0b\xc0\x2a\x19\xb2\xa5\x79\x48\xec\x49\xb6\xf0\x58\x7e\xe6\x82\x64\xc0\x98\xdb\xae\xf1\xe7\xcc\xfe\xae\xab\x46\xcd\xfe\x26\xaa\x74\x4f\xab\x40\x43\x42\x77\x6b\xce\x42\x58\x2b", 254);
syz_clone(0x400a0000, 0x20000880, 0x43, 0x20000900, 0, 0x20000980);
*(uint64_t*)0x20000c80 = 0x240800000;
*(uint64_t*)0x20000c88 = 0x20000a80;
*(uint64_t*)0x20000c90 = 0x20000ac0;
*(uint64_t*)0x20000c98 = 0x20000b00;
*(uint32_t*)0x20000ca0 = 0x18;
*(uint64_t*)0x20000ca8 = 0;
*(uint64_t*)0x20000cb0 = 0;
*(uint64_t*)0x20000cb8 = 0x20000c00;
*(uint64_t*)0x20000cc0 = 0x20000c40;
*(uint32_t*)0x20000c40 = 0;
*(uint32_t*)0x20000c44 = -1;
*(uint32_t*)0x20000c48 = 0;
*(uint32_t*)0x20000c4c = -1;
*(uint64_t*)0x20000cc8 = 4;
*(uint32_t*)0x20000cd0 = r[1];
syz_clone3(0x20000c80, 0x58);
*(uint64_t*)0x20000d40 = 0;
*(uint64_t*)0x20000d48 = 0;
*(uint64_t*)0x20000d50 = 0;
*(uint64_t*)0x20000d58 = 0x20000680;
*(uint32_t*)0x20000d60 = 0;
*(uint64_t*)0x20000d68 = 0;
*(uint64_t*)0x20000d70 = 0;
*(uint64_t*)0x20000d78 = 0;
*(uint64_t*)0x20000d80 = 0x20000d00;
*(uint32_t*)0x20000d00 = 0;
*(uint64_t*)0x20000d88 = 1;
*(uint32_t*)0x20000d90 = -1;
syz_clone3(0x20000d40, 0x58);
*(uint32_t*)0x20000e00 = 0;
*(uint32_t*)0x20000e04 = 0x80;
*(uint8_t*)0x20000e08 = 0x16;
*(uint8_t*)0x20000e09 = 0x25;
*(uint8_t*)0x20000e0a = 0;
*(uint8_t*)0x20000e0b = 0;
*(uint32_t*)0x20000e0c = 0;
*(uint64_t*)0x20000e10 = 0x100;
*(uint64_t*)0x20000e18 = 0x20000;
*(uint64_t*)0x20000e20 = 2;
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 0, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 1, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 2, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 3, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 4, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 5, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 6, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 7, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 8, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 9, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 10, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 11, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 12, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 13, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 14, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 15, 2);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 17, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 18, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 19, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 20, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 21, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 22, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 23, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 24, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 25, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 26, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 27, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 28, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 29, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 30, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 31, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 32, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 33, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 34, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 35, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 1, 36, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 37, 1);
STORE_BY_BITMASK(uint64_t, , 0x20000e28, 0, 38, 26);
*(uint32_t*)0x20000e30 = 5;
*(uint32_t*)0x20000e34 = 2;
*(uint64_t*)0x20000e38 = 0x20000dc0;
*(uint64_t*)0x20000e40 = 0;
*(uint64_t*)0x20000e48 = 1;
*(uint64_t*)0x20000e50 = 0x800;
*(uint32_t*)0x20000e58 = 0;
*(uint32_t*)0x20000e5c = 1;
*(uint64_t*)0x20000e60 = 0;
*(uint32_t*)0x20000e68 = 0;
*(uint16_t*)0x20000e6c = 6;
*(uint16_t*)0x20000e6e = 0;
*(uint32_t*)0x20000e70 = 0;
*(uint32_t*)0x20000e74 = 0;
*(uint64_t*)0x20000e78 = 0;
	syscall(__NR_perf_event_open, 0x20000e00ul, -1, 0ul, -1, 6ul);
	syscall(__NR_pipe, 0x20000f40ul);
	syscall(__NR_mkdirat, -1, 0ul, 0x1fful);
	return 0;
}
