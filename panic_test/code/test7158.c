// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

static long syz_open_procfs(volatile long a0, volatile long a1)
{
	char buf[128];
	memset(buf, 0, sizeof(buf));
	if (a0 == 0) {
		snprintf(buf, sizeof(buf), "/proc/self/%s", (char*)a1);
	} else if (a0 == -1) {
		snprintf(buf, sizeof(buf), "/proc/thread-self/%s", (char*)a1);
	} else {
		snprintf(buf, sizeof(buf), "/proc/self/task/%d/%s", (int)a0, (char*)a1);
	}
	int fd = open(buf, O_RDWR);
	if (fd == -1)
		fd = open(buf, O_RDONLY);
	return fd;
}

uint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
memcpy((void*)0x20000040, "/dev/loop-control\000", 18);
	res = syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000040ul, 0ul, 0ul);
	if (res != -1)
		r[0] = res;
	syscall(__NR_ioctl, r[0], 0x4c82, 0);
memcpy((void*)0x20000000, "/dev/loop-control\000", 18);
	res = syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000000ul, 0x80000ul, 0ul);
	if (res != -1)
		r[1] = res;
	syscall(__NR_ioctl, r[1], 0x4c81, 0ul);
memcpy((void*)0x200005c0, "/dev/vcsu\000", 10);
	res = syscall(__NR_openat, 0xffffffffffffff9cul, 0x200005c0ul, 0ul, 0ul);
	if (res != -1)
		r[2] = res;
	syscall(__NR_socket, 0x10ul, 3ul, 8);
syz_open_procfs(0, 0);
*(uint64_t*)0x20000880 = 0x20000740;
*(uint16_t*)0x20000740 = 0x10;
*(uint16_t*)0x20000742 = 0;
*(uint32_t*)0x20000744 = 0;
*(uint32_t*)0x20000748 = 8;
*(uint32_t*)0x20000888 = 0xc;
*(uint64_t*)0x20000890 = 0x20000840;
*(uint64_t*)0x20000840 = 0x200007c0;
*(uint32_t*)0x200007c0 = 0x5c;
*(uint16_t*)0x200007c4 = 0;
*(uint16_t*)0x200007c6 = 1;
*(uint32_t*)0x200007c8 = 0x70bd2d;
*(uint32_t*)0x200007cc = 0x25dfdbfb;
*(uint8_t*)0x200007d0 = 0xf;
*(uint8_t*)0x200007d1 = 0;
*(uint16_t*)0x200007d2 = 0;
*(uint16_t*)0x200007d4 = 0x14;
STORE_BY_BITMASK(uint16_t, , 0x200007d6, 3, 0, 14);
STORE_BY_BITMASK(uint16_t, , 0x200007d7, 0, 6, 1);
STORE_BY_BITMASK(uint16_t, , 0x200007d7, 1, 7, 1);
*(uint16_t*)0x200007d8 = 8;
*(uint16_t*)0x200007da = 3;
*(uint32_t*)0x200007dc = 0x8001;
*(uint16_t*)0x200007e0 = 8;
*(uint16_t*)0x200007e2 = 2;
*(uint32_t*)0x200007e4 = 0x9df;
*(uint16_t*)0x200007e8 = 0x34;
STORE_BY_BITMASK(uint16_t, , 0x200007ea, 3, 0, 14);
STORE_BY_BITMASK(uint16_t, , 0x200007eb, 0, 6, 1);
STORE_BY_BITMASK(uint16_t, , 0x200007eb, 1, 7, 1);
*(uint16_t*)0x200007ec = 8;
*(uint16_t*)0x200007ee = 2;
*(uint32_t*)0x200007f0 = 7;
*(uint16_t*)0x200007f4 = 8;
*(uint16_t*)0x200007f6 = 3;
*(uint32_t*)0x200007f8 = 0x3e;
*(uint16_t*)0x200007fc = 8;
*(uint16_t*)0x200007fe = 1;
*(uint32_t*)0x20000800 = -1;
*(uint16_t*)0x20000804 = 8;
*(uint16_t*)0x20000806 = 2;
*(uint32_t*)0x20000808 = 0;
*(uint16_t*)0x2000080c = 8;
*(uint16_t*)0x2000080e = 1;
*(uint32_t*)0x20000810 = 6;
*(uint16_t*)0x20000814 = 8;
*(uint16_t*)0x20000816 = 2;
*(uint32_t*)0x20000818 = 5;
*(uint64_t*)0x20000848 = 0x5c;
*(uint64_t*)0x20000898 = 1;
*(uint64_t*)0x200008a0 = 0;
*(uint64_t*)0x200008a8 = 0;
*(uint32_t*)0x200008b0 = 0x800;
	syscall(__NR_sendmsg, r[2], 0x20000880ul, 0x20000000ul);
memcpy((void*)0x200026c0, "./file0\000", 8);
	syscall(__NR_lstat, 0x200026c0ul, 0x20002700ul);
syz_open_procfs(0, 0);
	syscall(__NR_gettid);
	return 0;
}
