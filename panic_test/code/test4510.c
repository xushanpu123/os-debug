// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif
#ifndef __NR_statx
#define __NR_statx 332
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
	res = syscall(__NR_socket, 1ul, 1ul, 0);
	if (res != -1)
		r[0] = res;
	syscall(__NR_getpeername, r[0], 0ul, 0ul);
memcpy((void*)0x200006c0, "\x9e\x07\xff\xb4\x65\xd4\x54\x30\x53\xf6\xc0\xd8\xa8\xc8\xe4\x71\xee\x67\x5d\x8b\x57\x1b\x62\xbe\xb4\x17\x4d\xaa\x89\x40\x8e\x92\xe9\x93\x42\x02\xea\xdf\x12\xb5\xfc\x4c\x2a\x34\x19\x06\x64\x92\xb4\x72\x4e\x47\x1c\xc5\x02\x47\x5c\xe6\xbc\xf4\x6f\xa9\x31\x23\xd9\xf3\xd4\x3c", 68);
syz_clone(0x20201000, 0, 0, 0x20000640, 0, 0x200006c0);
memcpy((void*)0x20000740, "\x38\xac\x50\x32\xb8\x15\xdc\x8f\x65\x13\x75\x38\x3d\xae\x7c\xea\x37\x8f\x59\xc9\x62\x05\xe2\xae\x53\xd0\x4e\x97\x5f", 29);
syz_clone(0xa000000, 0x20000740, 0x1d, 0, 0x200007c0, 0x20000800);
	syscall(__NR_getgroups, 0ul, 0ul);
memset((void*)0x20000940, 0, 1);
	syscall(__NR_statx, 0xffffff9c, 0x20000940ul, 0ul, 0ul, 0x20000980ul);
	syscall(__NR_ioctl, -1, 0xc018937b, 0ul);
memcpy((void*)0x20001040, "\x81\x96\xdd\x32\xbf\x26\xe3\x66\x9f\xec\x07\xf8\x31\xa8\x82\x9d\x94\x46\xfb\x08\x67\xf6\xda\x23\x8c\x43\x16\x3b\xf0\x33\x3f\x78\x0f\x49\xd7\x09\xce\xab\x2c\xce\x75\x23\xaf\xf0\x9a\xcb\x8e\x93\xde\x16\x05\xb7\x35\xfb\x1f\xbe\x34\x95\x4b\xf9\x16\xd7\x27\x63\xcd\xd4\x4e\x0f\x3d\xfa\x41\x3a\x2c\x4d\x7e\xc3\x74\x44\x8e\xae\xb2\x34\x09\x4a\xc5\x7a\x47\x0b\x33\xf4\x83\x0e\xc5\x4e\x32\x80\x04\xf6\xc2\xf9\x35\xfb\x46\x05\x61\xd9\x9a\xa8\x7d\xd0\xb4\x42\xbc\x7b\x27\x34\xe8\x06\xc2\x78\xd0\x27\xff\xd4\xed\xfe\x37\xad\xfe\x41\x34\x36\x22\x78\x00\xd4\x7e\x59\xc7\xf2\x48\x9d\xce\x3d\xfe\x65\x42\xc3\xe0\x9a\x95\x38\xfd\xca\x01\xee\x52\x3a\x82\x6e\x0e\x96\xd4\x65\x52\x72\x8d\xc3\x8b\x1a\x71\xf1\x2f\xbd\x01\xf1\x04\x28\x41\xed\xe2\x63\xea\x4b\x74\xd9\x22\x07\x7b\xc7\x08\x07\xf3\x1d\x12\x86\xe1\x35\x4b\xce\x64\xdf\xa7\xe9\x7e\x86", 206);
memcpy((void*)0x200011c0, "\x47\x7f\x7c\x92\xa2\xa6\x7a\xe1\x55\x6c\x0e\x72\xc2\x16\xef\x12\xef\x46\x47\x13\xe7\x0b\xa5\xa6\x32\xf4\x2d\x5f\x0a\xef\xe1\x4c\xa4\xf5\xff\x43\xe4\x57\xde\x16\x3c\x1a\x55\x27\x1a\x59\x59\x66\x9a\xe5\xf7\xce\x02\x0f\x11\xee\x16\x42\x9f\x61\x2a\xab\x40\x2a\x88\xcf\xb6\x7e\x57\x5f\xb0\x77\x82\xec\x88\x3e\x1f\xaf\x20\x3d\x5d\xce\x67\xb8\x63\xeb\xd7\xe7\x16\x88\x07\x76\x62\x82\x50\x6f\x52\xa2\x0f\xe7\x6f\x19\x9f\x7b\xab\x32\x3a\x45\x08\x3e\xae\x9e\xe6\x51\x47\x25\x72\x29\x72\x2f\xf9\xda\x9b\x64\xe8\x5c\x83\x61\xe9\xbc\xa4\x0a\x08\x45\xa4\x3e\x30\xd1\x2e\xed\xcd\xbc\xa5\x56\x3d\xc4\xf8\x2a\x49\xde\x39\xbb\x15\xd1\x0f\x8b\x1f\x0d\xbd\x4b\x5d\x95\xa5\xc6\xed\x3c\x2a\x0a\xb3\x74\x0b\x3a\x01\xee\xd2\x46\x28\x73\xbd\x68\x04\x10\xd9\x75\xce\x73\xd2\x9c\x08\xe2\x57\x79\xcb\xb9\xb2\x41\xc0\x27\x20\x05\x08\xd4\x4b\x77\x22\x5e\xfb\xa3\x4d\xa9\x32\x94\xd6\x94\x06\xe1\xd9\x48\xc9\x2e\x68\xa2\x90\x89\x62\xca\xc2\x1c\xee\xdb\xcc\x3b\xae\xb8\x6a\x18\xbf", 237);
syz_clone(0, 0x20001040, 0xce, 0x20001140, 0x20001180, 0x200011c0);
memcpy((void*)0x200012c0, "\x3e\xda\xa4\xf1\xa3\xf0\xc1\x5e\xbe\x10\xd4\x34\x9a\x97\x52\x7f\x7e\xdb\x3c\x48\x4b\x74\xe3\x4e\x49\x36\x44\xfa\x27\x60\x22\xa4\x05\x7b\xa1\xb5\x60\xdb\x3c\xd1\x26\x29\x56\x7f\xed\x5e\xf6\xd0\x69\x9d\xed\x2c\xdb\x71\xfa\x9d\xb3\xe9\x74\xa3\xa5\x48\xe0\xd2\x94\xcb\x37\xbd\xa7\x0f", 70);
memcpy((void*)0x200013c0, "\x41\x9e\x03\x86\x68\x45\xd0\x57\x53\xc0\xdf\x76\x04\x8a\x52\xdc\xdc\x1a\xb8\xe4\x58\xec\x18\x5d\x3a\x24\x57\xad\xf9\x14\x06\xc6\x2e\xda\xa3\xb4\x39\xbd\xa3\xb3\xcc\x44\x69\x84\x95\x41\x7e\x35\x81\xd4\x50\x40\xf0", 53);
syz_clone(0x90100400, 0x200012c0, 0x46, 0x20001340, 0x20001380, 0x200013c0);
memcpy((void*)0x20001400, "./file0\000", 8);
	syscall(__NR_lstat, 0x20001400ul, 0x20001440ul);
	syscall(__NR_socket, 2ul, 0xaul, 6);
memcpy((void*)0x20001ac0, "msdos\000", 6);
memcpy((void*)0x20001b00, "./file0\000", 8);
*(uint64_t*)0x20002c80 = 0x20001bc0;
memcpy((void*)0x20001bc0, "\xb5\x9b\x96\xa4\x5b\x32\x84\xa8\xf0\x1f\x75\x25\xac\x89\x71\xde\x62\x33\x92\x2f\xce\x85\x61\x9a\x42\x7d\x12\x3f\x79\xaf\x51\xbe\x4f\x19\x97\xfe\xc2\x23\x12\xc5\xb1\x8f\x21\xee\xde\x5d\x80\xb6\xc7\xe1\xa1\x6b\x93\x0e\x64\x8f\x91\x33\x10\x5a\x22\x41\x0a\x39\xfd\x8e\x57\xc9\x93\x23\x24\xae\xf4\xf5\xa4\x70\x92\xc3\x91\x3a\x10\x0f\x46\x04\x96\x2d\x93\xbd\x05\xed\x7a\xaf\xd1\x50\x3a\x76\x04\x86\x44\xbe\x93\x90\xf3\xf4\x95\xed\x32\x6c\x60\x5f\x10\x47\x04\x64\x7d\x52\x36\xdd\x0b\xe3\x3c\x3b\x10\x4b\x11\x17\x4c\x2e\xde\x23\x4e\x7f\x09\x29\xa2\xd0\x3c\x81\x7f\x18\x0b\x9a\xa2\x08\xc3\x48\xa1\xfd\x26\x82\xed\xe3\x90\x97\x43\x08\x72\xdf\x63\x38\xab\x46\xe3\xd0\x38\xc5\x92\xa7\xeb\x8e\xa6\xd0\xe7\xdf\x2e\x5f\x6e\x34\x50\x8e\xb9\x73\xa0\xd9\xb1\x9d\xd9\x17\xa2\x17\x3d\x7d\xdf\x35\xcb\xaf\xfa\x9f\x87\x7b\x39\xc1\x40\xee\xe8\x21\xaa\x07\xd5\x13\xdd\x7c\xef\xc6\xfe\x6e\x1f\x7b\x48\x55\xf6\xdd\xbc\x61\x44\xe6\xcc\x68\xe6\x55\xae\x60\x4d\x69\x45\x9b\xa1\x51\xe9\xe4\xbf\x83\xf6\xc3\xe3\xb3\x2b\x64\x42\xf5\xd2\x1d\xfd\x33\x07\xf6\x9e\x34\xa8\x6f\xf7\x89\x6f\x62\xb4\xb1\x2f\x58\xfb\x6c\x04\x1a\x16\xdd\xf7\x21\x6c\xca\x57\x01\xba\x59\x08\xac\x02\x85\x12\x66\x33\x3c\x59\x28\x31\x6d\xb9\xdf\xe1\x7f\xd2\x7a\x59\x0b\x67\x15\x92\xe0\xdc\xbe\x06\x19\xd4\xfe\xed\x17\xd9\x65\x87\xc5\x7a\x09\xfc\xb6\xfb\x29\xf2\x31\xc2\x56\x33\x70\x03\x93\x2b\xd2\xe9\x0a\xd3\xed\x2b\x06\x6b\xe9\xad\x02\xc6\xa0\x72\xda\x16\x00\xad\xb3\xe0\x6c\xfc\x28\x80\xad\xf9\x42\xad\x2b\x20\xd0\x39\x71\x76\x8e\xaa\x81\xa1\x2c\xf2\x41\x99\x01\xd3\x7d\x75\xcf\x87\xfd\x2b\xa5\x79\xfd\xa2\xa0\x23\x70\x1a\x24\xfc\x73\x5b\x20\x9f\x2f\x58\x20\x1e\x9e\x68\xdb\x24\xb0\xa0\x14\x4c\xd8\xee\x72\x76\xe7\x1c\x29\x6f\x7d\xec\x9e\x73\x45\x55\xc5\x0b\xff\xf8\x39\xbc\x48\x7e\xd8\xe4\xe9\x67\xa3\x3d\xf2\xc5\x64\x88\x00\xc6\xec\xb7\x97\xc8\xdd\x6c\xc3\xe0\x36\xc7\x46\x5a\x1e\x07\xd9\x43\x26\x79\xf0\xec\xaa\xf6\xc2\x9c\x70\x11\x9a\x39\xa8\x21\x42\xf5\xfa\x78\x0b\x3c\x1d\x86\xcc\xbe\xa9\xa0\x39\xf9\xca\x72\x46\x80\x32\xb1\x68\x00\x11\xed\xa9\x08\xe4\xc6\xc8\x01\x59\x8b\x1f\x46\xba\x6f\x38\x60\x03", 512);
*(uint64_t*)0x20002c88 = 0x200;
*(uint64_t*)0x20002c90 = 0;
*(uint64_t*)0x20002c98 = 0x20001b40;
memcpy((void*)0x20001b40, "\x22\x17\x5e\xe2\xac\xaa\x2a\xd2\xdd\x75\xd4\x97\x0f\x1a\x9a\x36\x1d\xb0\xf2\xdf\x69\x37\x1f\xd4\xd6\xb6\x36\x80\x5e\xd6\x72\xc0\x2c\x88\xa5\xac\x78\x65\x3b\x6f\xa9\xf0\xad\x26\x17\x4d\x91\x82\xcc\x7e\xe3\x9f\x3b\xb5\xf2\x9c\xa5\x3e\xc9\xab\x99\x7d\x35\x13\xd5\x84\xc4\xe3\x6b\x89\x20\xb4\xe8\x2c\xb8\xb9\xba\xb3\xee\xb5\x0e\x55\x57\x9e\x62\x99\xf6\x55\xb9\x98\xdf\xd0\x1f\xff\xdf\xb8\x21\xc3\x47\x8b\x8a", 101);
*(uint64_t*)0x20002ca0 = 0x65;
*(uint64_t*)0x20002ca8 = 0x200;
*(uint64_t*)0x20002cb0 = 0x20002bc0;
memcpy((void*)0x20002bc0, "\x07\xca\x3e\xed\x5c\xef\x08\x62\xf2\x8e\x81\xa9\xe9\xbd\x4f\x2f\xc7\x7c\x57\xf2\x2c\xb0\x25\x68\x4a\x1d\xf7\x6f\x42\x0b\x65\x34\x33\x9a\xd4\x7c\x14\xeb\xad\x84\x19\x9e\xfa\x34\x71\xea\x96\x1f\xca\xa4\x5c\x3a\x33\xb3\x7e\x9c\x9f\x2f\x23\xd5\xde\xf6\xee\x64\xbc\x83\xc5\xef\x4a\xc2\x0d\x92\xb2\x33\x6d\xd4\x48\x29\x6d\x5a\x2c\xf4\x2a\xdb\x19\x99\x8d\x60\xf3\xc7\xc2\x3c\xd0\xfd\xe4\x5d\x1a\x3c\x4b\xce\x17\x1d\x80\x1d\x58\x94\xc6\xc8\xde\x77\x65\xce\xa4\x77\xfa\x37\x74\x3a\x32\x1c\xd0\xc0\xc9\xd7\xf4\x03\x0d\x07\x39\xfb\x06\x9a\x9d\x4c\xb0\x59\x53\xa6\x99\x20\x1b\x7f\x2b\xd9\x7b\xef\x47\x16\x5d\xa6\x4b\x20\xbc\x58\x7a\xab\x6c\x63\x49\xdd\x76\x87\x99\xf2\x7d\x42\x7e\xf3\x01\x84\x77", 171);
*(uint64_t*)0x20002cb8 = 0xab;
*(uint64_t*)0x20002cc0 = 0xfb7;
memcpy((void*)0x20002d00, "dots", 4);
*(uint8_t*)0x20002d04 = 0x2c;
memcpy((void*)0x20002d05, "dots", 4);
*(uint8_t*)0x20002d09 = 0x2c;
memcpy((void*)0x20002d0a, "dots", 4);
*(uint8_t*)0x20002d0e = 0x2c;
memcpy((void*)0x20002d0f, "dots", 4);
*(uint8_t*)0x20002d13 = 0x2c;
memcpy((void*)0x20002d14, "nodots", 6);
*(uint8_t*)0x20002d1a = 0x2c;
memcpy((void*)0x20002d1b, "nodots", 6);
*(uint8_t*)0x20002d21 = 0x2c;
memcpy((void*)0x20002d22, "euid<", 5);
sprintf((char*)0x20002d27, "%020llu", (long long)0xee01);
*(uint8_t*)0x20002d3b = 0x2c;
memcpy((void*)0x20002d3c, "subj_user", 9);
*(uint8_t*)0x20002d45 = 0x3d;
memcpy((void*)0x20002d46, ".\'*(}", 5);
*(uint8_t*)0x20002d4b = 0x2c;
memcpy((void*)0x20002d4c, "fsmagic", 7);
*(uint8_t*)0x20002d53 = 0x3d;
sprintf((char*)0x20002d54, "0x%016llx", (long long)0x7fff);
*(uint8_t*)0x20002d66 = 0x2c;
memcpy((void*)0x20002d67, "smackfstransmute", 16);
*(uint8_t*)0x20002d77 = 0x3d;
memcpy((void*)0x20002d78, "%t", 2);
*(uint8_t*)0x20002d7a = 0x2c;
*(uint8_t*)0x20002d7b = 0;
syz_mount_image(0x20001ac0, 0x20001b00, 0x1062, 3, 0x20002c80, 0x40009, 0x20002d00, 0);
memcpy((void*)0x200056c0, "msdos\000", 6);
memcpy((void*)0x20005700, "./file0\000", 8);
*(uint64_t*)0x200057c0 = 0x20005740;
memcpy((void*)0x20005740, "\x16\x6f\x9c\xae\xa3\xc0\x23\x88\xc8\xe6\x30\x11\xdb\x19\xec\x34\xc6\x1d\x7e\xeb\xb3\x9f\x80\x82\xb4\x2b\x8d\x59\xb6\x67\x27\xb1\x07\x74\x51\x5a\xf9\x09\xa2\xed\x2e\x38\x9d\x6a\x53\x4a\xcf\x5f\x17\x0a\xbc\x5c\xc5\x60\x50\xc9\xba\x6b\x87\xeb\xee\x6f\x04\xbf\xe8\xe6\xa0\xce\x85\x21\x4c\x68\xbb\xb0\x0e\x59\xe9\x6a\x06\x6c\x96\xdc\x67\x1e\x0d\xb2\xc5\xe6\x9f\xc0\x5d\xa2\xef\x0f\xda\x79\x09\x37\x81\x61\x89\x7a\x8c\xda\x75\x19\x76\x91\xb7\x06\xa4\xb5", 112);
*(uint64_t*)0x200057c8 = 0x70;
*(uint64_t*)0x200057d0 = 0xffff;
memcpy((void*)0x20005800, "nodots", 6);
*(uint8_t*)0x20005806 = 0x2c;
memcpy((void*)0x20005807, "dots", 4);
*(uint8_t*)0x2000580b = 0x2c;
memcpy((void*)0x2000580c, "nodots", 6);
*(uint8_t*)0x20005812 = 0x2c;
memcpy((void*)0x20005813, "debug", 5);
*(uint8_t*)0x20005818 = 0x2c;
memcpy((void*)0x20005819, "nodots", 6);
*(uint8_t*)0x2000581f = 0x2c;
memcpy((void*)0x20005820, "dots", 4);
*(uint8_t*)0x20005824 = 0x2c;
memcpy((void*)0x20005825, "dots", 4);
*(uint8_t*)0x20005829 = 0x2c;
memcpy((void*)0x2000582a, "dots", 4);
*(uint8_t*)0x2000582e = 0x2c;
memcpy((void*)0x2000582f, "nodots", 6);
*(uint8_t*)0x20005835 = 0x2c;
memcpy((void*)0x20005836, "dont_appraise", 13);
*(uint8_t*)0x20005843 = 0x2c;
memcpy((void*)0x20005844, "defcontext", 10);
*(uint8_t*)0x2000584e = 0x3d;
memcpy((void*)0x2000584f, "system_u", 8);
*(uint8_t*)0x20005857 = 0x2c;
memcpy((void*)0x20005858, "fowner>", 7);
sprintf((char*)0x2000585f, "%020llu", (long long)-1);
*(uint8_t*)0x20005873 = 0x2c;
memcpy((void*)0x20005874, "appraise", 8);
*(uint8_t*)0x2000587c = 0x2c;
memcpy((void*)0x2000587d, "hash", 4);
*(uint8_t*)0x20005881 = 0x2c;
*(uint8_t*)0x20005882 = 0;
syz_mount_image(0x200056c0, 0x20005700, 0x1006f, 1, 0x200057c0, 2, 0x20005800, 0);
	return 0;
}
