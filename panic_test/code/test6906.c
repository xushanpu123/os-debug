// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_read_part_table(volatile unsigned long size, volatile unsigned long nsegs, volatile long segments)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int err = 0, res = -1, loopfd = -1, memfd = -1;
	char loopname[64];
	snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
	if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
		return -1;
	struct loop_info64 info;
	if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	info.lo_flags |= LO_FLAGS_PARTSCAN;
	if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	res = 0;
	for (unsigned long i = 1, j = 0; i < 8; i++) {
		snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
		struct stat statbuf;
		if (stat(loopname, &statbuf) == 0) {
			char linkname[64];
			snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
			if (symlink(loopname, linkname)) {
			}
		}
	}
error_clear_loop:
	ioctl(loopfd, LOOP_CLR_FD, 0);
	close(loopfd);
	close(memfd);
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);

*(uint64_t*)0x20001640 = 0x20000380;
memcpy((void*)0x20000380, "\xc7\x4f\xec\x3f\x11\x25\xe8\x45\x86\x93\x39\x23\x93\xab\x8b\xaa\x42\x8d\x74\x57\x45\x60\x5d\x6f\x92\xbf\x32\xe1\xd4\x21\xe8\xc6\xa7\x54\xc8\x1b\xe9\x4b\xc3\x80\x41\xfc\x53\xb4\xc5\x9c\x8c\x58\xd6\x92\xfe\x2e\x1e\xcf\xa7\x04\x45\xd7\xb9\x3d\x12\x8a\x61\xf3\x41\x6b\xbc\x10\x00\xee\xdf\xc3\x9d\x52\x13\xce\xa8\x2a\xe7\xbf\x35\xd2\x71\x64\xa7\xd6\xbd\x9d\x8c\x61\xb6\x58\xe8\x53\xc7\x80\x5c\xb0\xd8\x7b\x56\x85\xbe\xe1\x81\x68\x30\xf2\x1e\x1d\x9b\x45\x5c\x13\x33\xf3\xc2\x26\xfc\x08\x3b\xeb\x34\x57\x9f\x66\xde\x61\xe1\x95\x2d\xbd\xd1\xcc\xad\xea\xe0\x13\xa6\xbf\x08\xac\x68\x6c\xe1\x17\xa7\x5e\x63\x0c\x8b\x2a\xd9\x10\x79\x40\xed\xf9\x10\xcd\xca\xa7\xa9\xc5\x2b\x13\x10\xcc\xc3\x9e\xd2\xe7\x04\x6f\xd1\x92\xb4\x36\xee\xcc\x39\x5d\xae\x70\xed\xe9\xdf\x26\x62\x37\xe3\xc7\x76\xef\x49\x22\x1b\xfa\xac\xb2\x3c\x98\x92\x00\xc3\xfe\xc6\x33\x0f\x93\xc8\x96\x11\x32\xe9\xb9\xf9\x87\xe1\x97\x19\x76\xfe\x06\x3a\xa7\x15\xb0\x7b\xe8\x7c\xff\x37\xd6\x58\x38\xb6\x2f\x6e\xaf\xb8\xb2\xda\xa0\x33\xdb\x3c\x69\xb9\x91\x2a\x00\xd7\x5c\xd3\x64\x1b\x33\x94\x4c\x9a\x85\xec\xe5\x18\xb0\x6e\x7d\x08\x61\x50\x66\xee\x6d\x0c\x66\x1d\xad\x93\xb0\x28\x3d\xa5\xcc\xce\xc2\x2a\xa9\xbd\x26\x27\xbb\x2e\xc6\xbb\x35\x07\xbb\xd4\xc0\x42\xbe\xaf\xae\xe9\x78\x05\x01\xc1\xd1\x64\x82\x19\x64\x02\x5c\x15\x58\xbc\x35\xa1\xa0\xbb\xa2\xcd\xdb\xdf\x38\xd0\xb1\xa9\x2d\x73\x5a\x6a\x4f\xc4\xae\x58\x57\x12\x0f\x60\x81\xe1\xba\x11\xaa\xb2\xc2\xb0\xe9\xfa\xf9\xd2\xef\x0f\x77\x6e\x90\x4f\xbb\xfc\x6b\x84\x65\xa5\x35\xaa\xed\xb8\x08\xc8\xa9\xb5\x6a\xbc\x45\x87\x23\xc4\x1b\xf0\x5e\xad\x66\xa7\xc6\x3c\x64\x42\x7c\xa0\x06\x0d\xec\x64\xe0\xeb\xcd\x81\xf8\x0c\xa9\x37\xad\x45\x4f\x94\x9c\xf5\xf9\x83\x8c\xc1\x7e\x68\x7d\xeb\xab\xff\x1d\xfa\xf3\xb1\xca\x22\x61\xea\x5f\x18\xb7\xcd\xde\xda\x49\x5b\x98\x3a\xd9\x88\xbe\x00\xaf\x32\x69\x1d\x07\x50\x77\x1c\x33\x73\x7c\x58\x51\x10\xa4\x09\xcb\x71\x50\xd4\x3d\xe9\xc2\x1f\x32\x1e\x92\x9c\x29\x50\x09\xbc\x4b\xf9\x6d\xba\x19\xaf\x3e\xc3\xf6\x90\xe7\xbd\x3e\x0c\x06\x8d\x7c\x10\x7c\x5f\xd4\x33\x5f\xda\x1c\x1d\xb9\x83\x1d\x94\xee\xb3", 507);
*(uint64_t*)0x20001648 = 0x1fb;
*(uint64_t*)0x20001650 = 5;
syz_read_part_table(0, 1, 0x20001640);
	return 0;
}
