// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_io_uring_enter
#define __NR_io_uring_enter 426
#endif
#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

#define SIZEOF_IO_URING_SQE 64
#define SIZEOF_IO_URING_CQE 16
#define SQ_HEAD_OFFSET 0
#define SQ_TAIL_OFFSET 64
#define SQ_RING_MASK_OFFSET 256
#define SQ_RING_ENTRIES_OFFSET 264
#define SQ_FLAGS_OFFSET 276
#define SQ_DROPPED_OFFSET 272
#define CQ_HEAD_OFFSET 128
#define CQ_TAIL_OFFSET 192
#define CQ_RING_MASK_OFFSET 260
#define CQ_RING_ENTRIES_OFFSET 268
#define CQ_RING_OVERFLOW_OFFSET 284
#define CQ_FLAGS_OFFSET 280
#define CQ_CQES_OFFSET 320

struct io_uring_cqe {
	uint64_t user_data;
	uint32_t res;
	uint32_t flags;
};

static long syz_io_uring_complete(volatile long a0)
{
	char* ring_ptr = (char*)a0;
	uint32_t cq_ring_mask = *(uint32_t*)(ring_ptr + CQ_RING_MASK_OFFSET);
	uint32_t* cq_head_ptr = (uint32_t*)(ring_ptr + CQ_HEAD_OFFSET);
	uint32_t cq_head = *cq_head_ptr & cq_ring_mask;
	uint32_t cq_head_next = *cq_head_ptr + 1;
	char* cqe_src = ring_ptr + CQ_CQES_OFFSET + cq_head * SIZEOF_IO_URING_CQE;
	struct io_uring_cqe cqe;
	memcpy(&cqe, cqe_src, sizeof(cqe));
	__atomic_store_n(cq_head_ptr, cq_head_next, __ATOMIC_RELEASE);
	return (cqe.user_data == 0x12345 || cqe.user_data == 0x23456) ? (long)cqe.res : (long)-1;
}

static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
memcpy((void*)0x20000000, "/dev/input/event#\000", 18);
syz_open_dev(0x20000000, 0x8000000000000001, 0);
	res = syscall(__NR_socket, 0x10ul, 3ul, 0x10);
	if (res != -1)
		r[0] = res;
*(uint64_t*)0x200011c0 = 0x200000c0;
*(uint16_t*)0x200000c0 = 0x10;
*(uint16_t*)0x200000c2 = 0;
*(uint32_t*)0x200000c4 = 0;
*(uint32_t*)0x200000c8 = 0x10000;
*(uint32_t*)0x200011c8 = 0xc;
*(uint64_t*)0x200011d0 = 0x20001180;
*(uint64_t*)0x20001180 = 0x20000200;
*(uint32_t*)0x20000200 = 0x14;
*(uint16_t*)0x20000204 = 0;
*(uint16_t*)0x20000206 = 0;
*(uint32_t*)0x20000208 = 0;
*(uint32_t*)0x2000020c = 0;
*(uint8_t*)0x20000210 = 0xe;
*(uint8_t*)0x20000211 = 0;
*(uint16_t*)0x20000212 = 0;
*(uint64_t*)0x20001188 = 0x14;
*(uint64_t*)0x200011d8 = 1;
*(uint64_t*)0x200011e0 = 0;
*(uint64_t*)0x200011e8 = 0;
*(uint32_t*)0x200011f0 = 0;
	syscall(__NR_sendmsg, r[0], 0x200011c0ul, 0ul);
*(uint64_t*)0x20001200 = 0x68;
	syscall(__NR_io_uring_enter, -1, 0, 0, 0ul, 0x20001200ul, 8ul);
syz_io_uring_complete(0);
	syscall(__NR_socket, 0xaul, 3ul, 2);
memcpy((void*)0x20001340, "nfs4\000", 5);
memcpy((void*)0x20001380, "./file0\000", 8);
*(uint64_t*)0x200026c0 = 0x20002600;
memcpy((void*)0x20002600, "\xac\xdc\x3e\x75\x57\x02\x50\xff\x14\xdd\xf2\xab\x11\x72\xe7\x97\xb4\xac\x9f\xf3\xfa\x45\xa5\xe3\x9c\x47\xd8\xb0\xb9\xe9\x03\xc8\xe9\x11\x4c\xb9\x88\x85\x0a\xa9\x11\xbe\x30\xf8\xce\xa8\x86\x68\x73\xe8\x36\x17\x7e\x09\x47\x1b\xf9\xa1\xed\x54\x35\x03\x3f\x8d\xbf\xc1\x6e\x67\x47\xf4\x26\x29\x0a\x66\xc6\x01\x85\x93\xc8\x8d\x5f\x72\xea\xb1\x14\xa6\x11\xa9\xfe\x44\xd2\x02\x47\xbf\xb1\x26\x23\xed\x6e\xf2\x93\xff\xd8\xb8\x0d\xfe\x2c\x32\x9c\x9a\x07\x8e\xa5\x99\x86\x38\x0a\x95\x97\x64\x7e\x03\x7a\xb1\x7d\x49\x02\xf8\x47\xf7\x61\x61\x55\x24\x02\xf5\xf9\x2b\x52\x9f\xc5\x7f\xea\xcf\xbb\x28\x43\xb9\x7b\x64\xaa\x30\x66\x8b\x8d\xd8\x80\x34\x37\xd9\xc1\xd7\x97\xeb\x76\xbe\x3e\xcb\xa2\x75\xa9\x24\x27\x62\x63\x6e\xd8\xe6\x9b", 179);
*(uint64_t*)0x200026c8 = 0xb3;
*(uint64_t*)0x200026d0 = 0x7ff;
memcpy((void*)0x20002780, "]$\t&/[.&k)\000", 11);
*(uint8_t*)0x2000278b = 0x2c;
memcpy((void*)0x2000278c, "smackfstransmute", 16);
*(uint8_t*)0x2000279c = 0x3d;
memcpy((void*)0x2000279d, "virt_wifi0\000", 11);
*(uint8_t*)0x200027a8 = 0x2c;
*(uint8_t*)0x200027a9 = 0;
syz_mount_image(0x20001340, 0x20001380, 0xcbb4, 1, 0x200026c0, 0, 0x20002780, 0);
	return 0;
}
