// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_read_part_table(volatile unsigned long size, volatile unsigned long nsegs, volatile long segments)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int err = 0, res = -1, loopfd = -1, memfd = -1;
	char loopname[64];
	snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
	if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
		return -1;
	struct loop_info64 info;
	if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	info.lo_flags |= LO_FLAGS_PARTSCAN;
	if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	res = 0;
	for (unsigned long i = 1, j = 0; i < 8; i++) {
		snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
		struct stat statbuf;
		if (stat(loopname, &statbuf) == 0) {
			char linkname[64];
			snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
			if (symlink(loopname, linkname)) {
			}
		}
	}
error_clear_loop:
	ioctl(loopfd, LOOP_CLR_FD, 0);
	close(loopfd);
	close(memfd);
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);

*(uint64_t*)0x20001080 = 0x20000080;
memcpy((void*)0x20000080, "\xfc\xe5\xa6\x9f\x3d\x81\xe3\x9e\x78\x71\xd7\xd0\xff\x36\x29\x53\x1f\x24\x85\x07\x73\x71\xf1\xe1\x44\x62\x5b\x8e\x0e\x4b\x64\xad\xaa\x96\x6a\x02\x03\xc6\x24\xac\x39\xe8\x86\xdd\x0f\x97\xc8\x62\x25\x2d\xe1\xc0\xed\x7a\x7e\x46\xa8\x67\x9b\xfb\x6e\x67\xdc\xc4\x37\x7c\x40\x10\x52\x3f\x92\x35\x2c\x11\x9f\x7a\x9c\x3c\x2f\x7a\x38\x53\xe3\xe9\xe5\x97\xbf\x1e\x6f\x29\xc8\xb7\xdb\x2f\x03\x0a\x56\xc9\x76\xff\x5a\xe4\xcb\xa1\xfb\x13\xda\x48\x7e\x9d\x45\xc9\xf0\xc8\xa1\xb4\x88\x4d\xb5\xbb\xaa\xab\x6b\x3c\x03\x6c\xd4\xc9\xc5\x11\x37\xfe\xdb\xa7\x32\x72\xe8\x6c\xaa\xf7\x5d\x35\x24\x1e\xe4\x67\xfc\x68\x8a\x7d\x7f\x0d\x6b\x6a\xc7\x98\xda\xbc\x1c\xeb\x8b\xaa\x45\xd8\x23\x6f\xd9\xbb\xfc\xc1\x77\xe3\xa0\xc8\x24\x09\xec\xf6\x08\x90\xee\x85\xcc\xb2\xa6\x9b\x4b\x8b\xc5\x34\x5a\x5c\x7d\xcb\x7b\x03\xfd\x62\xe3\xd2\x33\xb5\xe3\x52\xf7\x9c\x12\xbc\x2c\xe0\xe7\x91\x82\x48\x24\xa2\xfc\xff\xe9\xc7\xc8\x65\xf9\x87\x91\x1e\xe8\x87\x3f\x95\xaa\x4c\x5c\x15\x5b\xf1\x1f\x4a\x18\xd9\xdd\xfb\xe7\x26\x0e\x14\x93\x53\x32\xfa\x64\x79\x09\x17\xfd\x3d\x75\xc8\x44\x18\xf3\x48\x66\x66\xb2\xa6\x01\x70\x8e\xa9\xf8\xa4\x53\x2b\xdc\x9b\xef\x7b\x03\xfa\x59\xf5\xe2\xbf\x46\x9d\x20\x72\xa2\x16\xf4\x46\xc6\xa5\xff\x0d\xc1\x63\x0e\x06\x40\x7c\xfe\x26\xdf\x1d\x7c\x52\x30\x1c\x71\x72\x26\x02\xb8\x9f\x8a\x25\x2e\x0f\x44\x83\xf2\x6d\xc8\x4e\x73\xd5\x9c\xc0\x66\x7c\x84\x36\x93\xf3\x62\x12\xd3\x83\xd5\xac\x1c\x5a\x68\x30\x24\xb3\xc2\xdc\x1b\x6a\xa2\x84\x52\x2f\x10\x77\x56\x8a\x89\xa6\xf5\xe4\x8b\xf4\xe7\xf6\x78\x0d\x71\xab\x89\x15\x28\x1d\x5b\x04\x4e\x2c\xf1\xba\x8e\xb1\x57\xce\xda\xa7\xad\x02\xeb\xc9\x23\x1d\x19\x4f\x26\x3a\x89\xfc\x2e\xbf\xf0\x8b\x3f\xb4\x90\x23\x2e\xe0\x52\xd9\x24\x2c\x4a\x31\x31\xc0\xfa\x8c\xca\x8d\xe2\x67\x83\x64\xd9\x3e\x23\x5d\x6c\x7d\xad\x65\x4e\x03\x83\x5a\x9d\xa1\x78\x16\x19\xca\x48\xb9\xb1\xb8\x8c\x80\x0a\x09\x0b\x3f\xa6\xc9\x1e\x40\x73\xee\x5a\xf0\xe2\x64\x63\xa4\xe2\xdd\x61\xdd\x32\x00\x9b\x07\xc5\x9a\x47\x0d\xa3\x46\xd7\x1f\x9b\x43\x41\x78\x6c\xd5\xf8\x08\x3c\x4f\xae\xe4\x57\x12\x2f\xbd\x6a\xcf\xc4\x07\xcf\xc4\xac\xc6\xcb", 507);
*(uint64_t*)0x20001088 = 0x1fb;
*(uint64_t*)0x20001090 = 5;
syz_read_part_table(0, 1, 0x20001080);
	return 0;
}
