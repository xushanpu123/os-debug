// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}

static long syz_open_procfs(volatile long a0, volatile long a1)
{
	char buf[128];
	memset(buf, 0, sizeof(buf));
	if (a0 == 0) {
		snprintf(buf, sizeof(buf), "/proc/self/%s", (char*)a1);
	} else if (a0 == -1) {
		snprintf(buf, sizeof(buf), "/proc/thread-self/%s", (char*)a1);
	} else {
		snprintf(buf, sizeof(buf), "/proc/self/task/%d/%s", (int)a0, (char*)a1);
	}
	int fd = open(buf, O_RDWR);
	if (fd == -1)
		fd = open(buf, O_RDONLY);
	return fd;
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
syz_open_procfs(0, 0);
	res = -1;
res = syz_open_dev(0xc, 4, 0x15);
	if (res != -1)
		r[0] = res;
*(uint64_t*)0x200030c0 = 0x20000040;
memcpy((void*)0x20000040, "\x73\xea\x44\x3c\xbb\x92\x8f\xfd\x3c\x8e\xd3\xba\xce\xfa\x64\xd5\x67\xde\xdc\x80\x89\x09\x1a\xa5\xbc\xf6\xdc\x6b\x6b\xfe\x99\xa0\x80\xac\xc1\xb3\x4d\x7b\x6e\xa3\x77\xc9\x64\x21\x83\x66\xa6\x0a\xf1\x0d\x52\x99\xce\x6f\x6c\x0b\x81\x2b\xc3\x37\x5d\x80\x10\x2a\x33\x0a\x3b\xf9\x86\xe9\xcb\x4d\xd1\x99\xce\x3c\xaf\x63\x13\xe3\xec\xff\x67\x46\x62\x4b\xaf\xc1\x31\x53\xec\xc6\x4a\xb9\x80\xc9\x71\xfb\xdf\xc8\x3c\x68\x7f\x57\x6e\x91\x08\x6d\x3b\xa3\x3e\x0c\x98\xce\x92\x05\x5c\x01\x38\x69\xbc\xc4\x61\x16\x53\x6a\xb2\xe9\x53\x36\xbd\x88\xcf\x77\xcb\x8a\xde\x8b\xe0\x1d\x05\x0b\xe4\x1e\x49\xaa\x6e\x06\x89\x8e\x47\xca\xc9\x35\x1c\xdc\x4f\x90\xcf\x15\xbd\xc9\xf7\xf5\xe0\x81\xe8\xb9\x65\x80\x65\xcd\xdd\xcd\x3d\x55\xef\x8f\x1f\xc1\x34\x3c\x1d\xfc\x16\x4e\x1b\xa2\x72\x59\xbc\x87\xdd\x33\xfa\xf9\xf6\xd3\xd9\xcf\x62\x75\xd4\x3d\xc9\x61\xa9\x5b\x97\x22\x1c\x5f\xb0\x03\x3b\xbe\x72\x76\xa5\x53\xb9\x3a\xfc\x5c\x4a\xa2\x92\xb7\x4c\x91\xb3\x5e\x9f\x12\xc1\xd1\x4e\xae\x29\xe4\x31\x18\xc9\x6d\xbe\x6c\xfe\x50\xb3\xcb\x9c\xc9\xeb\x19\x61\x80\x03\x98\xd3\x39\x3f\xb8\x57\xc3\x35\x8b\xd6\x72\xff\x23\x30\xc0\xeb\x0f\x7a\x3e\xa4\xe0\xbc\x96\xe7\x23\x96\xa7\x7a\xfd\xd9\x08\xf6\xa1\x28\x0b\x04\x76\xdc\xeb\xdd\x49\x88\x60\x51\x49\xdd\x0c\x0c\x0e\x4f\x47\x39\x82\xc3\xb8\xfc\x57\xfe\x45\x73\x51\xcd\xc6\x90\x92\x56\xba\xeb\xb8\x5c\x14\xc3\x7f\x7b\x93\xb8\x4f\x00\xcc", 336);
*(uint64_t*)0x200030c8 = 0x150;
	syscall(__NR_writev, r[0], 0x200030c0ul, 1ul);
	return 0;
}
