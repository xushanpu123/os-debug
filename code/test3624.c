// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_read_part_table(volatile unsigned long size, volatile unsigned long nsegs, volatile long segments)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int err = 0, res = -1, loopfd = -1, memfd = -1;
	char loopname[64];
	snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
	if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
		return -1;
	struct loop_info64 info;
	if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	info.lo_flags |= LO_FLAGS_PARTSCAN;
	if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	res = 0;
	for (unsigned long i = 1, j = 0; i < 8; i++) {
		snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
		struct stat statbuf;
		if (stat(loopname, &statbuf) == 0) {
			char linkname[64];
			snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
			if (symlink(loopname, linkname)) {
			}
		}
	}
error_clear_loop:
	ioctl(loopfd, LOOP_CLR_FD, 0);
	close(loopfd);
	close(memfd);
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);

*(uint64_t*)0x20002400 = 0x20000000;
memcpy((void*)0x20000000, "\xe0\xd3\xf5\x3a\x48\x4e\x50\x91\xc9\xec\x1e\x83\xe7\x14\xa7\xb8\xa5\xbb\xf2\xb9\x78\x27\x65\x31\x55\x54\x2d\xd9\x90\xfb\x7f\xd0\x71\x77\x39\x51\x40\x08\xd4\xf7\x0d\x5f\x60\x2b\xa1\xc9\x07\x1c\x29\x6d\x36\x11\x74\x63\x58\x1a\xe8\xdd\x75\xe3\x6e\x56\x42\x61\x5f\x0b\x72\x3b\xc1\x3d\x90\x02\x66\xed\x5d\x05\x5c\xc3\x97\x48\xf0\xe0\x27\x1a\x62\x11\x18\xc2\x6e\x8f\xf6\x47\x5f\x57\x02\xd9\xcc\x4a\xb4\x39\x3e\x27\x53\xc3\xce\xde\x50\xd3\xea\x03\xcc\x5e\x26\x87\xc0\xee\x49\xd1\xc5\x5a\xd9\xaf\x9f\xd5\x67\xb9\xba\xff\x06\xde\x50\x3c\x67\x2f\x7a\xb2\x4f\x9b\xc0\x03\x55\xdf\x87\xe1\x92\x49\x42\x85\x71\x41\xf2\xfa\x0d\x37\xba\x7e\x6c\x90\x17\x19\x07\x22\x76\x58\xf3\x6f\x87\x95\x89\x29\x21\x9d\xf3\x1c\x62\x91\x1d\x20\xd9\x01\x1d\xa9\x47\x26\x7b\x50\x0c\x18\xf7\x3c\x8a\x29\x5d\x60\xb2\x01\xcb\x9a", 198);
*(uint64_t*)0x20002408 = 0xc6;
*(uint64_t*)0x20002410 = 0x8000000000000000;
*(uint64_t*)0x20002418 = 0x20000100;
memcpy((void*)0x20000100, "\xae\x39\x19\xa9\xe2\x15\x10\x5d\xa7\xa8\x5a\xe9\xf9\x23\x91\x99\xb5\x8f\x2e\x28\x16\x9f\x49\x1f\x4b\x1f\xab\xa1\x93\xe5\xe1\x29\xbd\x28\xa1\xfd\x09\x3e\x2f\x55\x64\x02\xd7\x1f\x0d\xe8\xbf\x7d\x53\xf5\x33\x36\x89\x2f\x8d\x16\x22\x05\xbe\x07\x76\x02\x3a\x3b\x8d\x03\x03\xb9\x3c\x9d\xd5\x09\x1b\xcd\x1b\xed\x48\x70\xa6\xb8\x78\x67\xb0\x80\x09\xdc\x52\x66\x53\x69\xde\x39\xfd\x14\xd0\x27\x1c\x8c\x8e\xc0\xd1\xf5\x7f\xb8\xde\x31\x6d\xe2\x71\x7e\x23\xf6\x6e\x42\x09\xeb\x40\xb5\x44\x16\x02\x1a\x92\x98\x70\x87\x61\x45\xff\x32\x10\xad\x02\xc3\xdf\x4f\x4c\x81\x5c\xad\x33\x1b\xea\x3e\x35\xec\xc7\x7e\x43\x0f\xb8\x82\xb2\xf4\xcd\x2c\xed\xc3\x05\x08\x70\x1b\x1a\x04\xe4\x0b\xe2\x40\x44\x09\xf6\xd0\xe3\x25\x27\x3b\x4e\x7c\x27\x91\x94\x92\x4f\x69\x90\x42\x83\x91\x59\x2c\x59\xbc\x75\x12\xbe\x3a\x30\xed\x71\x75\x45\xd8\xa6\xb3\x29\x92\xf7\x26\x7a\xb0\x1c\x24\xa8", 213);
*(uint64_t*)0x20002420 = 0xd5;
*(uint64_t*)0x20002428 = 0x6307;
*(uint64_t*)0x20002430 = 0x20000200;
memcpy((void*)0x20000200, "\x9a\xe6\x91\xa9\x6d\x36\x62\x96\xda\x3c\x96\x66\xeb\x70\xab\xe9\xfb\x13\x69\xcf\xa6\x1b\x56\x28\xb4\x6d\x15\x12\x26\x65\xd7\x7a\xfe\x90\x9d\x01\x78\x34\xa2\x44\x42\xda\xa3\x9a\x50\xd3\x11\x07\xc5\x6a\xa3\x19\x3b\x34\x10\x1f\x5a\xac\x40\x8a\xf9\x1d\x29\x53\xeb\x93\xb8\x31\xcb\x72\xd7\xf7\x1e\x23\x85\x98\xb0\x27\x2b\x68\x4e\x1f\x75\x2d\xff\x64\x9a\xf8\x8f\xa5\x8f\x50\x0c\xf6\x24\xe2\x3a\x03\x81\xd1\x7b\x88\xc6\xc8\x5e\xde\x45\xf4", 108);
*(uint64_t*)0x20002438 = 0x6c;
*(uint64_t*)0x20002440 = 5;
*(uint64_t*)0x20002448 = 0x20000280;
*(uint64_t*)0x20002450 = 0;
*(uint64_t*)0x20002458 = 0x8000000000000000;
syz_read_part_table(0, 4, 0x20002400);
	return 0;
}
