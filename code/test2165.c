// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_link.h>
#include <linux/in6.h>
#include <linux/loop.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct nlmsg {
	char* pos;
	int nesting;
	struct nlattr* nested[8];
	char buf[4096];
};

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
			 const void* data, int size)
{
	memset(nlmsg, 0, sizeof(*nlmsg));
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_type = typ;
	hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
	memcpy(hdr + 1, data, size);
	nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ,
			 const void* data, int size)
{
	struct nlattr* attr = (struct nlattr*)nlmsg->pos;
	attr->nla_len = sizeof(*attr) + size;
	attr->nla_type = typ;
	if (size > 0)
		memcpy(attr + 1, data, size);
	nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock,
			    uint16_t reply_type, int* reply_len, bool dofail)
{
	if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
	exit(1);
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;
	struct sockaddr_nl addr;
	memset(&addr, 0, sizeof(addr));
	addr.nl_family = AF_NETLINK;
	ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));
	if (n != (ssize_t)hdr->nlmsg_len) {
		if (dofail)
	exit(1);
		return -1;
	}
	n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	if (reply_len)
		*reply_len = 0;
	if (n < 0) {
		if (dofail)
	exit(1);
		return -1;
	}
	if (n < (ssize_t)sizeof(struct nlmsghdr)) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type == NLMSG_DONE)
		return 0;
	if (reply_len && hdr->nlmsg_type == reply_type) {
		*reply_len = n;
		return 0;
	}
	if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type != NLMSG_ERROR) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	errno = -((struct nlmsgerr*)(hdr + 1))->error;
	return -errno;
}

static int netlink_query_family_id(struct nlmsg* nlmsg, int sock, const char* family_name, bool dofail)
{
	struct genlmsghdr genlhdr;
	memset(&genlhdr, 0, sizeof(genlhdr));
	genlhdr.cmd = CTRL_CMD_GETFAMILY;
	netlink_init(nlmsg, GENL_ID_CTRL, 0, &genlhdr, sizeof(genlhdr));
	netlink_attr(nlmsg, CTRL_ATTR_FAMILY_NAME, family_name, strnlen(family_name, GENL_NAMSIZ - 1) + 1);
	int n = 0;
	int err = netlink_send_ext(nlmsg, sock, GENL_ID_CTRL, &n, dofail);
	if (err < 0) {
		return -1;
	}
	uint16_t id = 0;
	struct nlattr* attr = (struct nlattr*)(nlmsg->buf + NLMSG_HDRLEN + NLMSG_ALIGN(sizeof(genlhdr)));
	for (; (char*)attr < nlmsg->buf + n; attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
		if (attr->nla_type == CTRL_ATTR_FAMILY_ID) {
			id = *(uint16_t*)(attr + 1);
			break;
		}
	}
	if (!id) {
		errno = EINVAL;
		return -1;
	}
	recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	return id;
}

#define SIZEOF_IO_URING_SQE 64
#define SIZEOF_IO_URING_CQE 16
#define SQ_HEAD_OFFSET 0
#define SQ_TAIL_OFFSET 64
#define SQ_RING_MASK_OFFSET 256
#define SQ_RING_ENTRIES_OFFSET 264
#define SQ_FLAGS_OFFSET 276
#define SQ_DROPPED_OFFSET 272
#define CQ_HEAD_OFFSET 128
#define CQ_TAIL_OFFSET 192
#define CQ_RING_MASK_OFFSET 260
#define CQ_RING_ENTRIES_OFFSET 268
#define CQ_RING_OVERFLOW_OFFSET 284
#define CQ_FLAGS_OFFSET 280
#define CQ_CQES_OFFSET 320

struct io_uring_cqe {
	uint64_t user_data;
	uint32_t res;
	uint32_t flags;
};

static long syz_io_uring_complete(volatile long a0)
{
	char* ring_ptr = (char*)a0;
	uint32_t cq_ring_mask = *(uint32_t*)(ring_ptr + CQ_RING_MASK_OFFSET);
	uint32_t* cq_head_ptr = (uint32_t*)(ring_ptr + CQ_HEAD_OFFSET);
	uint32_t cq_head = *cq_head_ptr & cq_ring_mask;
	uint32_t cq_head_next = *cq_head_ptr + 1;
	char* cqe_src = ring_ptr + CQ_CQES_OFFSET + cq_head * SIZEOF_IO_URING_CQE;
	struct io_uring_cqe cqe;
	memcpy(&cqe, cqe_src, sizeof(cqe));
	__atomic_store_n(cq_head_ptr, cq_head_next, __ATOMIC_RELEASE);
	return (cqe.user_data == 0x12345 || cqe.user_data == 0x23456) ? (long)cqe.res : (long)-1;
}

static long syz_genetlink_get_family_id(volatile long name, volatile long sock_arg)
{
	int fd = sock_arg;
	if (fd < 0) {
		fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
		if (fd == -1) {
			return -1;
		}
	}
	struct nlmsg nlmsg_tmp;
	int ret = netlink_query_family_id(&nlmsg_tmp, fd, (char*)name, false);
	if ((int)sock_arg < 0)
		close(fd);
	if (ret < 0) {
		return -1;
	}
	return ret;
}

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);

syz_io_uring_complete(0);
syz_genetlink_get_family_id(0, -1);
memcpy((void*)0x20000880, "iso9660\000", 8);
memcpy((void*)0x200008c0, "./file0\000", 8);
*(uint64_t*)0x20001c40 = 0x200019c0;
memset((void*)0x200019c0, 68, 1);
*(uint64_t*)0x20001c48 = 1;
*(uint64_t*)0x20001c50 = 0;
*(uint64_t*)0x20001c58 = 0x20000900;
memcpy((void*)0x20000900, "\x8b\xfc\x42\xd0\x81\xdf\x33\x04\xeb\xef\x08\xf4\x3d\x03\xb5\xfa\xcc\xe7\x5f\xa8\x3e\x00\xc3\x14\x58\xd8\x08\xd0\xa3\x6d\x79\x09\xba\x57\x81\x30\x04\x28\x85\x64\x55\x27\xc1\xa3\x49\x5f\xc5\x25\x1c\xdf\x4d\x79\xc7\x8f\xc1\x6b\xd9\x9e\x5f\x9b\x4d\x3b\x88\x0a\xc9\xc1\x99\xfd\x17\x54\xf8\x95\xe7\xaa\x46\xb7\x0f\x01\x0f\xb3\x73\x23\xb1\x5c\x47\x7c\x8c\xcd\xd8\xbb\xcc\x03\x4a\xd2\xa8\x53\x44\xbc\x53\x35\x7d\x32\x73\xba\x05\x9d\xcb\xb0\x9a\xd3\xd0\x9c\xd9\xf5\x70\x68\xa1\xf2\x45\xab\x6a\xaa\xf5\xad\xd6\xa8\x36\xdd\xe6\x64\xba\xb2\x77\x78\xb5\x5a\x83\x5a\x5d\x15\xb8\x8f\xf4\xe5\xf8\x62\x92\xc1\x20\x09\xab\x1e\x73\x22\x1f\x78\xd9\x58\x8d\x69\xd7\x17\xe9\x0f\x6b\x08\x93\x33\xc5\x65\x76\xdb\xbc\x63\xc4\x51\x59\xad\xf6\x43\xf5\x5b\x26\xe0\x34\x09\xfb\x11\x2c\xe6\xb3\x29\x1d\xe8\xde\x35\x9f\x82\x24\xa9\x69\x73\x62\x53\xd2\x5b\xd7\x45\x70\x3f\x56\xd2\x31\x9e\xb4\x48\x67\xa2\xf4\x9a\x14\x39\x8c\x62\x24\x35\x48\x05\xdc\x41\x8f\x60\x53\x1a\xac\x41\x70\x0c\xc8\x7c\x38\xf5\xee\x31\xf4\x6c\xeb\xe4\x82\xb3\xbd\x50\x36\xb8\x3e\xfd\xe2\xe3\xf2\xb2\x3d\x5d\x99\xde\xb0\x67\xf0\xf9\x83\xa3\x73\xba\x0a\xe2\xe9\xd1\xf1\xc8\xf6\x53\xd1\x41\x7f\x74\xb5\x2b\x1f\xbd\x67\x08\x28\x44\x58\x13\x57\x43\xa4\x69\x94\x29\x7d\xd9\x63\x1f\x21\x60\xd3\x58\x08\x6c\xb4\x5e\x3b\x0c\x91\x48\xda\x3c\x3e\x3d\x4b\x5d\x68\xd2\xf6\xa2\x54\x45\x09\xb9\xb5\xcf\x4e\xd0\x24\xe8\xa6\x27\x0e\x20\x58\xad\xed\x4a\xdc\x12\x86\xa3\x81\xa1\x9a\xb8\x6e\xa6\xf6\x7b\xea\x84\x0b\x73\x89\x6b\x92\x02\xb0\x5b\x94\x17\xcc\x66\xfc\x4e\x6f\xfd\x6d\x6e\xa8\xb3\x4d\x93\xd8\xfa\xd9\x7c\x8e\xf9\xd6\xac\x7b\x8b\xdc\x51\xf3\xf6\x83\x4b\x1e\x51\x0c\xff\xa5\xb0\x94\xba\xe5\xf8\x2f\x5e\x28\xf4\x31\x0d\x83\x82\xef\x8d\x06\xaa\x6a\x3c\x4d\x42\x6f\x64\x60\xd6\x17\x80\x9d\xb8\xde\x20\x96\xd6\xbf\xa2\x91\x8a\x39\x79\x35\x4d\x2e\xe3\xd4\xbe\x26\x27\xcb\x00\x0c\x1d\x98\xcf\xf8\x22\xe3\x93\xd0\xea\xe6\xe1\x7b\x0c\x1c\x6c\x9a\x66\xc4\x23\x3b\x03\xcd\x42\xbb\xeb\x57\xe7\x4d\x08\x49\x4f\xe8\x87\x7c\xf0\xb8\xed\x35\x94\xe6\x84\x30\x24\x18\x37\x92\x85\x3b\x4a\x37\x85\x03\x23\xb0\x37\x0b\x2f\x25\x82\x3c\x30\x02\xaf\xa3\xca\x0d\x3a\xd2\x85\x96\xc3\x7c\x71\x56\xcb\x84\x9f\x43\xb1\xf1\xe4\x34\xf9\xc7\x81\xd2\x1f\x9f\x17\x97\x7a\x2f\x75\x1a\x26\x6a\xd1\xa6\x3f\x45\x76\x25\xe8\x9a\x7b\x52\x3e\xcf\xa1\x94\x66\xf0\x54\x8c\x91\x75\xac\x10\x81\x1b\xa2\x48\xd7\xb9\x2a\xf1\x6d\xf3\x2f\xbd\x80\x32\xa8\x85\x96\x13\xbd\xf0\x4e\xf1\xf9\x3b\x6e\xd2\xbe\x5b\xe0\xe0\xea\x92\x22\xfc\x7e\x9f\x8c\xa9\xb0\xe5\xe8\xf8\x8f\xff\x8b\xb1\xd8\x3a\xe4\x07\xc4\xa7\x37\x9c\x67\x9f\xcd\x4e\x34\x7b\xae\x99\x64\x4b\x92\x3c\x36\x6f\x2a\x65\x4f\x6f\x4d\x96\x00\x77\xf4\x61\xc2\x96\x69\x57\x97\xf3\x9e\x20\xf5\x5c\xdc\x72\x9e\x3c\x3d\xf7\xb5\xf0\x52\x91\xd0\x87\xa6\x5c\xd6\xc1\x3f\xae\xac\x0e\xdd\x8d\x17\x09\x6e\xac\x40\x0f\x92\x36\x62\xb1\xb8\x07\xb1\xb8\xd9\x10\x47\x20\x2c\xda\x62\x52\x45\x0c\x22\xdd\xea\x0c\x3d\xd4\x05\x44\x3f\x16\x00\xfe\xc9\xb6\xa4", 718);
*(uint64_t*)0x20001c60 = 0x2ce;
*(uint64_t*)0x20001c68 = 0x2400000;
memcpy((void*)0x20001d00, "unhide", 6);
*(uint8_t*)0x20001d06 = 0x2c;
memcpy((void*)0x20001d07, "iocharset", 9);
*(uint8_t*)0x20001d10 = 0x3d;
memcpy((void*)0x20001d11, "cp949", 5);
*(uint8_t*)0x20001d16 = 0x2c;
memcpy((void*)0x20001d17, "check=relaxed", 13);
*(uint8_t*)0x20001d24 = 0x2c;
memcpy((void*)0x20001d25, "euid<", 5);
sprintf((char*)0x20001d2a, "%020llu", (long long)0xee00);
*(uint8_t*)0x20001d3e = 0x2c;
memcpy((void*)0x20001d3f, "fowner<", 7);
sprintf((char*)0x20001d46, "%020llu", (long long)0xee01);
*(uint8_t*)0x20001d5a = 0x2c;
memcpy((void*)0x20001d5b, "func", 4);
*(uint8_t*)0x20001d5f = 0x3d;
memcpy((void*)0x20001d60, "CREDS_CHECK", 11);
*(uint8_t*)0x20001d6b = 0x2c;
*(uint8_t*)0x20001d6c = 0;
syz_mount_image(0x20000880, 0x200008c0, 0x24002ce, 2, 0x20001c40, 0x190000, 0x20001d00, 0);
	return 0;
}
