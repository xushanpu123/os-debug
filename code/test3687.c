// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				syscall(__NR_ioctl, -1, 0x8933, 0ul);
	syscall(__NR_prctl, 0x53564d41ul, 0ul, 0x20ffa000ul, 0x4000ul, 0ul);
memcpy((void*)0x20000880, "iso9660\000", 8);
memcpy((void*)0x200008c0, "./file0/file0\000", 14);
*(uint64_t*)0x20000bc0 = 0x20000ac0;
memcpy((void*)0x20000ac0, "\xf6\xa6\x78\x0a\xf7\x36", 6);
*(uint64_t*)0x20000bc8 = 6;
*(uint64_t*)0x20000bd0 = 0;
*(uint64_t*)0x20000bd8 = 0x20000a00;
memset((void*)0x20000a00, 63, 1);
*(uint64_t*)0x20000be0 = 1;
*(uint64_t*)0x20000be8 = 6;
*(uint64_t*)0x20000bf0 = 0x20000b00;
memcpy((void*)0x20000b00, "\x3e\xd1\x30\x9d\x8c\x68\x8c\x9e\x11\xa0\xa2\x3b\x97\xbf\x25\x56\xfa\x8a\xda\xac\x45\x69\xd9\x92\xb6\x84\x8f\x1a\x39\x32\x60\xc6\x90\xea\x94\x35\x00\x1b\xa5\xac\xc2\x6c\x0e\x40\x61\xd4\xa2\xbc\xc8\x3e\xe2\x48\x6b\x33\x60\x7c\x09\x89\x43\x65\x68\x57\xa8\x0b\x8e\x0f\x02\xc3\xca\x06\xec", 71);
*(uint64_t*)0x20000bf8 = 0x47;
*(uint64_t*)0x20000c00 = 7;
*(uint64_t*)0x20000c08 = 0x20000900;
memcpy((void*)0x20000900, "\x92\xa5\x1c\xcd\x47\xc1\x7e\x4c\x29\xe6\x9d\x9b\x68\x88\xed\x76\xbe\x57\x0c\xf9\x18\xd8\xb8\xe3\x39\x93\x22\xaf\x7b\xe5\x1d\x91\x95\x61\x48\x67\xa3\x9c\x88\xee\x44\x64\x20\x6e\x96\xa7\xa6\x3e\x3a\x37\x22\xc4\x8c\x52\x12\x63\xbb\xc4\xa1\xe8\x60\xc6\x7c\x72\x1f\xf9\x67\x29\xed\x22\x6c\x3e\x19\x39\x2e\x22\x2e\xea\x28\x23\x93\xb9\x06\xe5\x7e\xdd\x74\x9a\x17\x81\x45\x75\x35\x38\x92\xb2\x34\x83\x68\xe4\x53\x18\xe6\x10\xfc\x34\x1c\x55\x75\x85\x1f\xbd\xb8\x59\xbb\xde\x2a\xc3\x3c\xc3\x65\x22\x3b\xfe\x66\x40\xd3\x51\x10\x0b\x13\x44\x2b\x7d\x47\x69\x1e\xf4\x30\x71\x95\x43\x90\x4a\x6d\x9a\x42\x8a\xff\x69\xac\x64\x56\x4f\x90\xfb\x92\xbf\xe2\x26\xa4\x62\x97\xcc\xa1\x9a\x66\x5d\xbc\x9d\xa1\x58\x09\x9f\x59\x33\x13\xa9\x44\x5b\xe4\xb7\x1f\xc9\x64\x0c\x67\xab\xb9\x42\x42\x0f\x08\x65\xb4\xc9\xa6\x2e\xf2\xfb\x1b\x89\xc1\xde\x08\x56\x33\x9c\x5c\x26\xc0\xa7\x52\xca\xd1\xe8\x70\xf2\xb7\xd1\x7f\xe7\x11\x27\x73\x22\x82", 227);
*(uint64_t*)0x20000c10 = 0xe3;
*(uint64_t*)0x20000c18 = 0xe804;
memcpy((void*)0x20000c40, "hide", 4);
*(uint8_t*)0x20000c44 = 0x2c;
memcpy((void*)0x20000c45, "overriderockperm", 16);
*(uint8_t*)0x20000c55 = 0x2c;
memcpy((void*)0x20000c56, "nojoliet", 8);
*(uint8_t*)0x20000c5e = 0x2c;
memcpy((void*)0x20000c5f, "iocharset", 9);
*(uint8_t*)0x20000c68 = 0x3d;
memcpy((void*)0x20000c69, "cp437", 5);
*(uint8_t*)0x20000c6e = 0x2c;
memcpy((void*)0x20000c6f, "map=off", 7);
*(uint8_t*)0x20000c76 = 0x2c;
*(uint8_t*)0x20000c77 = 0;
syz_mount_image(0x20000880, 0x200008c0, 0xe8e7, 4, 0x20000bc0, 0x4000c, 0x20000c40, 0);
	return 0;
}
