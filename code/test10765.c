// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sched.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_link.h>
#include <linux/in6.h>
#include <linux/loop.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct nlmsg {
	char* pos;
	int nesting;
	struct nlattr* nested[8];
	char buf[4096];
};

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
			 const void* data, int size)
{
	memset(nlmsg, 0, sizeof(*nlmsg));
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_type = typ;
	hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
	memcpy(hdr + 1, data, size);
	nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ,
			 const void* data, int size)
{
	struct nlattr* attr = (struct nlattr*)nlmsg->pos;
	attr->nla_len = sizeof(*attr) + size;
	attr->nla_type = typ;
	if (size > 0)
		memcpy(attr + 1, data, size);
	nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock,
			    uint16_t reply_type, int* reply_len, bool dofail)
{
	if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
	exit(1);
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;
	struct sockaddr_nl addr;
	memset(&addr, 0, sizeof(addr));
	addr.nl_family = AF_NETLINK;
	ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));
	if (n != (ssize_t)hdr->nlmsg_len) {
		if (dofail)
	exit(1);
		return -1;
	}
	n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	if (reply_len)
		*reply_len = 0;
	if (n < 0) {
		if (dofail)
	exit(1);
		return -1;
	}
	if (n < (ssize_t)sizeof(struct nlmsghdr)) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type == NLMSG_DONE)
		return 0;
	if (reply_len && hdr->nlmsg_type == reply_type) {
		*reply_len = n;
		return 0;
	}
	if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type != NLMSG_ERROR) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	errno = -((struct nlmsgerr*)(hdr + 1))->error;
	return -errno;
}

static int netlink_query_family_id(struct nlmsg* nlmsg, int sock, const char* family_name, bool dofail)
{
	struct genlmsghdr genlhdr;
	memset(&genlhdr, 0, sizeof(genlhdr));
	genlhdr.cmd = CTRL_CMD_GETFAMILY;
	netlink_init(nlmsg, GENL_ID_CTRL, 0, &genlhdr, sizeof(genlhdr));
	netlink_attr(nlmsg, CTRL_ATTR_FAMILY_NAME, family_name, strnlen(family_name, GENL_NAMSIZ - 1) + 1);
	int n = 0;
	int err = netlink_send_ext(nlmsg, sock, GENL_ID_CTRL, &n, dofail);
	if (err < 0) {
		return -1;
	}
	uint16_t id = 0;
	struct nlattr* attr = (struct nlattr*)(nlmsg->buf + NLMSG_HDRLEN + NLMSG_ALIGN(sizeof(genlhdr)));
	for (; (char*)attr < nlmsg->buf + n; attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
		if (attr->nla_type == CTRL_ATTR_FAMILY_ID) {
			id = *(uint16_t*)(attr + 1);
			break;
		}
	}
	if (!id) {
		errno = EINVAL;
		return -1;
	}
	recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	return id;
}

static long syz_genetlink_get_family_id(volatile long name, volatile long sock_arg)
{
	int fd = sock_arg;
	if (fd < 0) {
		fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
		if (fd == -1) {
			return -1;
		}
	}
	struct nlmsg nlmsg_tmp;
	int ret = netlink_query_family_id(&nlmsg_tmp, fd, (char*)name, false);
	if ((int)sock_arg < 0)
		close(fd);
	if (ret < 0) {
		return -1;
	}
	return ret;
}

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

uint64_t r[11] = {0x0, 0x0, 0x0, 0x0, 0xffffffffffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
	res = syscall(__NR_shmget, 0ul, 0x2000ul, 0x10ul, 0x20ffc000ul);
	if (res != -1)
		r[0] = res;
	res = syscall(__NR_shmget, 0ul, 0x3000ul, 0x1000ul, 0x20ffc000ul);
	if (res != -1)
		r[1] = res;
	syscall(__NR_shmctl, 0, 0xeul, 0x20000000ul);
	res = syscall(__NR_shmget, 0ul, 0x2000ul, 0x78000000ul, 0x20ffb000ul);
	if (res != -1)
		r[2] = res;
	res = syscall(__NR_getgid);
	if (res != -1)
		r[3] = res;
*(uint32_t*)0x200000c0 = 1;
*(uint32_t*)0x200000c4 = 1;
*(uint32_t*)0x200000c8 = 0x18;
*(uint32_t*)0x200000cc = -1;
*(uint32_t*)0x200000d0 = 0xee01;
*(uint32_t*)0x200000d4 = -1;
memcpy((void*)0x200000d8, "./file0\000", 8);
	res = syscall(__NR_ioctl, -1, 0xc018937b, 0x200000c0ul);
	if (res != -1) {
r[4] = *(uint32_t*)0x200000cc;
r[5] = *(uint32_t*)0x200000d0;
r[6] = *(uint32_t*)0x200000d4;
	}
*(uint32_t*)0x20000100 = 0x798e2633;
*(uint32_t*)0x20000104 = 0xee01;
*(uint32_t*)0x20000108 = r[3];
*(uint32_t*)0x2000010c = r[5];
*(uint32_t*)0x20000110 = -1;
*(uint32_t*)0x20000114 = 2;
*(uint16_t*)0x20000118 = 3;
*(uint32_t*)0x2000011c = 0x6ac2;
*(uint64_t*)0x20000120 = 1;
*(uint64_t*)0x20000128 = 0x1ff;
*(uint64_t*)0x20000130 = 8;
*(uint32_t*)0x20000138 = -1;
*(uint32_t*)0x2000013c = 0;
*(uint16_t*)0x20000140 = 0;
*(uint16_t*)0x20000142 = 0;
*(uint64_t*)0x20000148 = 0;
*(uint64_t*)0x20000150 = 0;
	syscall(__NR_shmctl, r[2], 1ul, 0x20000100ul);
*(uint32_t*)0x20000180 = 1;
*(uint32_t*)0x20000184 = 1;
*(uint32_t*)0x20000188 = 0x18;
*(uint32_t*)0x2000018c = r[4];
*(uint32_t*)0x20000190 = -1;
*(uint32_t*)0x20000194 = r[6];
memcpy((void*)0x20000198, "./file0/file0\000", 14);
	syscall(__NR_ioctl, r[4], 0xc018937b, 0x20000180ul);
*(uint32_t*)0x200001c0 = 1;
*(uint32_t*)0x200001c4 = 1;
*(uint32_t*)0x200001c8 = 0x18;
*(uint32_t*)0x200001cc = r[4];
*(uint32_t*)0x200001d0 = r[5];
*(uint32_t*)0x200001d4 = r[6];
memcpy((void*)0x200001d8, "./file0\000", 8);
	res = syscall(__NR_ioctl, r[4], 0xc018937b, 0x200001c0ul);
	if (res != -1)
r[7] = *(uint32_t*)0x200001d0;
memcpy((void*)0x20000200, "\x23\xc3\x1b\x91\xf2\x87\x75\x9b\x3a\xec\x66\x03\x83\xa6\x55\x4b\x5f\x1a\x7e\x0f\x52\x90\x31\x8d\x56\x31\xc8\x81\x46\x6f\xd0\x06\x25\x64\xef\x31\x18\xeb", 38);
memcpy((void*)0x20000300, "\xfd\x3b\x91\xcb\x47\x5f\xe9\x13\xe7\x0e\x81\xd5\xcb\x04\xf3\xbf\x07\x55\x70\x1b\x05\x39\x8f\x0c\x73\xe7\xd9\x01\x45\x24\x43\x54\xc2\x27\x8f\xa8\xfb\x34\x36\xf6\xe4\x55\x4e\xce\x30\xeb\x8b\x89\xaf\xb9\x6c\xa0\x85\x02\x11\x5d\xbf\xe5\xae\x41\x43\x1d\xa9\xea\x1c\x22\xdd\x47\xb9\x7a\x0b\xa5\xd1\xc2\x66\x5b\x6e\x18\x9d\x49\xd1\x77\xaf\x50\xc4\x43\x16\xf8\xc0\x2b\xa2\x34\x5a\x79\xf6\x50\x01\x5d\xe8\x46\xc9\x2e\xba\x41\x04\x1a\xde\x1f\x30\x9c\x33\xf2\xbc\x5b\x91\xfc\xb4\xc3\xea\xca\x4a\xc6\x3c\x92\xf4\x76\x86\x67\x35\x97\x54\xc7\xdb\x17\xca\x1e\xa9\xd1\xcf\xba\x35\x16\x9b\x7a\x55\xf1", 146);
	res = -1;
res = syz_clone(0x4000000, 0x20000200, 0x26, 0, 0x200002c0, 0x20000300);
	if (res != -1)
		r[8] = res;
memcpy((void*)0x200003c0, "\xcb\x33\x70\x55\xcc\x48\x46\xa5\xb2\x06\xfc\x26\x81\xb0\xc9\xeb\x0e\x39\xd1\x39\x32\x72\xc6\x3c\x83\x46\x1e\xed\xe3\x95\xa0\x33\xfe\x5e\xef\xc7\xa8\x75\xfd\x3b\x07\xfd\xdf\xc8\xfe\x34\x47\xd7\x63\x0c\xee\x0c\x0e\xd7\xb2\xad\xb9\x97\x9f\xc6\x67\xef\x4d\x22\xef\xaa\x55\xee\x65\xf8\xb4\x38\x7d\x8a\xfe\x8f\x6d\xe1\xe1\x6c\xcd\x9c\x18\xa4\xd8\x78\xdf\xc7\x69\xe4\xd3\x6e\x68\xfa\x98\x99\x7f\x17\x57\xc9\x0b\xd3\x8e\x46\xf5\x19\x4c\xc0\x15\xe1\x81\x6d\x23\x0a\xfc\x36\xd0\x46\x1b\xb4\x0e\xc8\x38\x1d\xd3\x40\x80\xa5\xa5\x92\xfe\xa4\xc9\x65\xf8\x69\x90\x42\x4e\xb6\xa2\x6c\x96\x95\x16\x1c\xcb\x53\xa9\x2d\x18\x07\x2b\x6a\x1c\xd3\x0b\x59\xc2\x6f\x4e\x56\x0f\x01\xc7\x69", 166);
	res = -1;
res = syz_clone(0, 0x200003c0, 0xa6, 0x20000480, 0, 0x20000500);
	if (res != -1)
		r[9] = res;
*(uint32_t*)0x200005c0 = 0x798e2636;
*(uint32_t*)0x200005c4 = r[5];
*(uint32_t*)0x200005c8 = 0;
*(uint32_t*)0x200005cc = r[7];
*(uint32_t*)0x200005d0 = r[3];
*(uint32_t*)0x200005d4 = 0x80;
*(uint16_t*)0x200005d8 = 4;
*(uint32_t*)0x200005dc = 0x81;
*(uint64_t*)0x200005e0 = 2;
*(uint64_t*)0x200005e8 = 0;
*(uint64_t*)0x200005f0 = 3;
*(uint32_t*)0x200005f8 = r[8];
*(uint32_t*)0x200005fc = r[9];
*(uint16_t*)0x20000600 = 0;
*(uint16_t*)0x20000602 = 0;
*(uint64_t*)0x20000608 = 0;
*(uint64_t*)0x20000610 = 0;
	syscall(__NR_shmctl, r[0], 1ul, 0x200005c0ul);
memcpy((void*)0x200008c0, "nl802154\000", 9);
syz_genetlink_get_family_id(0x200008c0, -1);
	syscall(__NR_shmctl, r[1], 0xeul, 0ul);
memcpy((void*)0x20000a00, "ext4\000", 5);
memcpy((void*)0x20000a40, "./file0\000", 8);
*(uint64_t*)0x20000bc0 = 0x20000a80;
memcpy((void*)0x20000a80, "\x17\xa4\xf5\xa9\x58\x99\x9c\xf2\x2a\xbf\x0a\x8d\x2e\x9d\xcd\x6c\x3e\x7b\x58\xd6\x04\x3d\xe6\xa6\x9e\x15\xd3\x90\xdb\xde\x8a\x98\x97\x0d\xdf\x54\x37\xff\xd9\xc6\xa1\x20\xf6\x4d\x5d\x80\x01\xa8\x21\xff\x7d\x49\xe7\xe8\x1f\x42\xe6\x0f\x1d\x28\x35\x18\x64\x82\x89\x6a\xbd\xe5\x9c\xbd\x68\xdf\x6a\xa5\x0e\x76\x4b\xf6\x77\x1d\xe0\xbb\x6d\x98\x68\x37\x47\x63\x5b\x9a\x51\xd6\x27\x4e\xa7\x41\x6f\xbe\xfa\x4b\x85\xef\xd2\x18\xa9\x51\x12\x28", 108);
*(uint64_t*)0x20000bc8 = 0x6c;
*(uint64_t*)0x20000bd0 = 0x1f;
*(uint64_t*)0x20000bd8 = 0x20000b00;
memcpy((void*)0x20000b00, "\xd7\xe3\xdc\x59\xc6\x17\x0d\x91\x77\x10\xad\x62\x8d\x2f\xc1\x2d\x9e\xab\xf9\xb3\x24\x24\xef\x28\x4e\xeb\xd7\x3b\x50\xc5\x04\x59\xdc\x74\x8c\xdd\x04\x04\x15\xb2\x4a\x50\x22\x84\x4a\x13\xd9\x9d\x13\x5d\xdf\x39\x6d\xed\xfe\x0a\xf6\xe1\xdc\x75\x62\xbe\xaf", 63);
*(uint64_t*)0x20000be0 = 0x3f;
*(uint64_t*)0x20000be8 = 0x800;
memcpy((void*)0x20000c00, "user_xattr", 10);
*(uint8_t*)0x20000c0a = 0x2c;
memcpy((void*)0x20000c0b, "lazytime", 8);
*(uint8_t*)0x20000c13 = 0x2c;
memcpy((void*)0x20000c14, "hash", 4);
*(uint8_t*)0x20000c18 = 0x2c;
*(uint8_t*)0x20000c19 = 0;
	res = -1;
res = syz_mount_image(0x20000a00, 0x20000a40, 0x83f, 2, 0x20000bc0, 0x8081, 0x20000c00, 0);
	if (res != -1)
		r[10] = res;
memcpy((void*)0x20000c40, "./file0\000", 8);
	syscall(__NR_unlinkat, r[10], 0x20000c40ul, 0x200ul);
	return 0;
}
