// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>
#include <linux/sched.h>

#ifndef __NR_clone3
#define __NR_clone3 435
#endif
#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

#define MAX_CLONE_ARGS_BYTES 256
static long syz_clone3(volatile long a0, volatile long a1)
{
	unsigned long copy_size = a1;
	if (copy_size < sizeof(uint64_t) || copy_size > MAX_CLONE_ARGS_BYTES)
		return -1;
	char clone_args[MAX_CLONE_ARGS_BYTES];
	memcpy(&clone_args, (void*)a0, copy_size);
	uint64_t* flags = (uint64_t*)&clone_args;
	*flags &= ~CLONE_VM;
	return handle_clone_ret((long)syscall(__NR_clone3, &clone_args, copy_size));
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				syscall(__NR_getpid);
*(uint64_t*)0x200002c0 = 0x20000;
*(uint64_t*)0x200002c8 = 0x20000100;
*(uint64_t*)0x200002d0 = 0x20000140;
*(uint64_t*)0x200002d8 = 0x20000180;
*(uint32_t*)0x200002e0 = 0x35;
*(uint64_t*)0x200002e8 = 0x200001c0;
*(uint64_t*)0x200002f0 = 0x33;
*(uint64_t*)0x200002f8 = 0x20000200;
*(uint64_t*)0x20000300 = 0x20000280;
*(uint32_t*)0x20000280 = -1;
*(uint32_t*)0x20000284 = 0;
*(uint64_t*)0x20000308 = 2;
*(uint32_t*)0x20000310 = -1;
syz_clone3(0x200002c0, 0x58);
memcpy((void*)0x200003c0, "iso9660\000", 8);
memcpy((void*)0x200004c0, "./file0\000", 8);
*(uint64_t*)0x20000780 = 0x20000540;
memcpy((void*)0x20000540, "\x40\x22\xae\xf6", 4);
*(uint64_t*)0x20000788 = 4;
*(uint64_t*)0x20000790 = 3;
*(uint64_t*)0x20000798 = 0x20000680;
memcpy((void*)0x20000680, "\x1f\x1b\x2c\x2d\x64\x7d\x31\x91\xfc\x5a\xae\xa3\xcb\x1b\x4d\xba\x36\xbb\x84\xfd\x0c\xf6\xd3\x28\xe8\xd2\x47\x2b\xd9\x92\xa3\xe2\x3b\x1d\x69\xee\xda\xc6\xff\x31\x65\xd4\x71\xf2\xa6\x9e\x88\xc6\x21\x58\x11\xd9\x9a\x76\xb2\x6a\x97\x25\xf5\x25\xe1\x6f\x4a\x68\xf1\x5a\xa4\x66\xd7\x98\xf3\x2e\xcc\x1a\xd8\x9c\x55\x9c\x05\xe9\x5a\xe4\x1d\x58\x7c\xcc\xb9\x5e\xcc\xe7\x95\xb9\x5a\x5d\xc2\x29\x41\xc8\xd2\x9d\x0e\xc4\x17\xdc\x0a\xbc\x36\x97\x88\x09\x71\x1f\xc1\xaf\xbf\xac\x5b\x57\x64\x80\x60\x87\x69\x1e\x72\x8c\x2e\xd7\xb1\x46\x46\xba\xc9\x6f\x7a\xdb\xdd\x10\x37\xcb\x08\xa6\xf3\x20\xc8\x45\x7c\xd3\xc8\x96\x8d\xc5\x04\x07\x91\x1e\x0c\x4c\xc6\x2a\x54\xac\x86\x91\xb7\x5a\xb6\xb5\x21\x28\x1d\x9a\x76\x41\x8b\xe7\x76\xf6\xc9\xfc\x8a\x79\x56\x3f\x6a\xd6\x5a\xd3\x5f\x93\xa9\x4e\xb0\xe3\xb1\x60\x32\xa8\x53\x36\xfb\x85\xa5\x9f\x48\x16\xb2\xef\x8a\xb9\x6a\x4f\x77\x16\x83\xd3\x36\xc2\xb2\xe2\xc2\x65\x34\x7b\xf7\x81\xa5\x17\xcf\x6c\xae\x43\xe0", 233);
*(uint64_t*)0x200007a0 = 0xe9;
*(uint64_t*)0x200007a8 = 7;
memcpy((void*)0x20000800, "mode", 4);
*(uint8_t*)0x20000804 = 0x3d;
sprintf((char*)0x20000805, "0x%016llx", (long long)2);
*(uint8_t*)0x20000817 = 0x2c;
memcpy((void*)0x20000818, "unhide", 6);
*(uint8_t*)0x2000081e = 0x2c;
memcpy((void*)0x2000081f, "smackfshat", 10);
*(uint8_t*)0x20000829 = 0x3d;
memcpy((void*)0x2000082a, "\',}$\000", 5);
*(uint8_t*)0x2000082f = 0x2c;
memcpy((void*)0x20000830, "euid", 4);
*(uint8_t*)0x20000834 = 0x3d;
sprintf((char*)0x20000835, "%020llu", (long long)0);
*(uint8_t*)0x20000849 = 0x2c;
memcpy((void*)0x2000084a, "uid", 3);
*(uint8_t*)0x2000084d = 0x3d;
sprintf((char*)0x2000084e, "%020llu", (long long)-1);
*(uint8_t*)0x20000862 = 0x2c;
memcpy((void*)0x20000863, "audit", 5);
*(uint8_t*)0x20000868 = 0x2c;
memcpy((void*)0x20000869, "fowner>", 7);
sprintf((char*)0x20000870, "%020llu", (long long)-1);
*(uint8_t*)0x20000884 = 0x2c;
*(uint8_t*)0x20000885 = 0;
syz_mount_image(0x200003c0, 0x200004c0, 0xffff, 2, 0x20000780, 0x200400, 0x20000800, 0);
memcpy((void*)0x20000340, "\',}$\000", 5);
	syscall(__NR_memfd_create, 0x20000340ul, 4ul);
	syscall(__NR_socket, 1ul, 2ul, 0);
*(uint64_t*)0x20003fc0 = 0x20000940;
*(uint32_t*)0x20003fc8 = 0x6e;
*(uint64_t*)0x20003fd0 = 0x20000cc0;
*(uint64_t*)0x20000cc0 = 0x200009c0;
*(uint64_t*)0x20000cc8 = 0xc5;
*(uint64_t*)0x20000cd0 = 0;
*(uint64_t*)0x20000cd8 = 0;
*(uint64_t*)0x20000ce0 = 0;
*(uint64_t*)0x20000ce8 = 0;
*(uint64_t*)0x20003fd8 = 3;
*(uint64_t*)0x20003fe0 = 0;
*(uint64_t*)0x20003fe8 = 0;
*(uint32_t*)0x20003ff0 = 0;
*(uint32_t*)0x20003ff8 = 0;
*(uint64_t*)0x20004000 = 0x20000dc0;
*(uint32_t*)0x20004008 = 0x6e;
*(uint64_t*)0x20004010 = 0x20001300;
*(uint64_t*)0x20001300 = 0x20000f40;
*(uint64_t*)0x20001308 = 0xb0;
*(uint64_t*)0x20001310 = 0x20001000;
*(uint64_t*)0x20001318 = 0xf8;
*(uint64_t*)0x20001320 = 0;
*(uint64_t*)0x20001328 = 0;
*(uint64_t*)0x20001330 = 0x20001180;
*(uint64_t*)0x20001338 = 6;
*(uint64_t*)0x20001340 = 0x200011c0;
*(uint64_t*)0x20001348 = 0xd9;
*(uint64_t*)0x20001350 = 0x200012c0;
*(uint64_t*)0x20001358 = 0x26;
*(uint64_t*)0x20004018 = 6;
*(uint64_t*)0x20004020 = 0;
*(uint64_t*)0x20004028 = 0;
*(uint32_t*)0x20004030 = 0;
*(uint32_t*)0x20004038 = 0;
*(uint64_t*)0x20004040 = 0x20001380;
*(uint32_t*)0x20004048 = 0x6e;
*(uint64_t*)0x20004050 = 0x20001740;
*(uint64_t*)0x20001740 = 0x20001400;
*(uint64_t*)0x20001748 = 0x78;
*(uint64_t*)0x20001750 = 0x20001480;
*(uint64_t*)0x20001758 = 2;
*(uint64_t*)0x20001760 = 0x200014c0;
*(uint64_t*)0x20001768 = 0x1a;
*(uint64_t*)0x20001770 = 0x20001500;
*(uint64_t*)0x20001778 = 0x60;
*(uint64_t*)0x20001780 = 0x20001580;
*(uint64_t*)0x20001788 = 0xb5;
*(uint64_t*)0x20001790 = 0x20001640;
*(uint64_t*)0x20001798 = 0xc2;
*(uint64_t*)0x20004058 = 6;
*(uint64_t*)0x20004060 = 0x200017c0;
*(uint64_t*)0x20004068 = 0x40;
*(uint32_t*)0x20004070 = 0;
*(uint32_t*)0x20004078 = 0;
*(uint64_t*)0x20004080 = 0x20001840;
*(uint32_t*)0x20004088 = 0x6e;
*(uint64_t*)0x20004090 = 0x20002a00;
*(uint64_t*)0x20002a00 = 0x200018c0;
*(uint64_t*)0x20002a08 = 0x1000;
*(uint64_t*)0x20002a10 = 0x200028c0;
*(uint64_t*)0x20002a18 = 0x18;
*(uint64_t*)0x20002a20 = 0x20002900;
*(uint64_t*)0x20002a28 = 0xed;
*(uint64_t*)0x20004098 = 3;
*(uint64_t*)0x200040a0 = 0;
*(uint64_t*)0x200040a8 = 0;
*(uint32_t*)0x200040b0 = 0;
*(uint32_t*)0x200040b8 = 0;
*(uint64_t*)0x200040c0 = 0x20002a40;
*(uint32_t*)0x200040c8 = 0x6e;
*(uint64_t*)0x200040d0 = 0x20003e40;
*(uint64_t*)0x20003e40 = 0x20002ac0;
*(uint64_t*)0x20003e48 = 0x99;
*(uint64_t*)0x20003e50 = 0x20002b80;
*(uint64_t*)0x20003e58 = 0x1000;
*(uint64_t*)0x20003e60 = 0x20003b80;
*(uint64_t*)0x20003e68 = 0x6b;
*(uint64_t*)0x20003e70 = 0x20003c00;
*(uint64_t*)0x20003e78 = 0x31;
*(uint64_t*)0x20003e80 = 0x20003c40;
*(uint64_t*)0x20003e88 = 0xa6;
*(uint64_t*)0x20003e90 = 0x20003d00;
*(uint64_t*)0x20003e98 = 0xc0;
*(uint64_t*)0x20003ea0 = 0x20003dc0;
*(uint64_t*)0x20003ea8 = 0x3a;
*(uint64_t*)0x20003eb0 = 0x20003e00;
*(uint64_t*)0x20003eb8 = 0x37;
*(uint64_t*)0x200040d8 = 8;
*(uint64_t*)0x200040e0 = 0x20003ec0;
*(uint64_t*)0x200040e8 = 0xe0;
*(uint32_t*)0x200040f0 = 0;
*(uint32_t*)0x200040f8 = 0;
*(uint64_t*)0x20004100 = 0;
*(uint64_t*)0x20004108 = 0;
	syscall(__NR_recvmmsg, -1, 0x20003fc0ul, 5ul, 0x40000000ul, 0x20004100ul);
	return 0;
}
