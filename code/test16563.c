// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

static long syz_open_procfs(volatile long a0, volatile long a1)
{
	char buf[128];
	memset(buf, 0, sizeof(buf));
	if (a0 == 0) {
		snprintf(buf, sizeof(buf), "/proc/self/%s", (char*)a1);
	} else if (a0 == -1) {
		snprintf(buf, sizeof(buf), "/proc/thread-self/%s", (char*)a1);
	} else {
		snprintf(buf, sizeof(buf), "/proc/self/task/%d/%s", (int)a0, (char*)a1);
	}
	int fd = open(buf, O_RDWR);
	if (fd == -1)
		fd = open(buf, O_RDONLY);
	return fd;
}

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_mount_image(volatile long fsarg, volatile long dir, volatile unsigned long size, volatile unsigned long nsegs, volatile long segments, volatile long flags, volatile long optsarg, volatile long change_dir)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int res = -1, err = 0, loopfd = -1, memfd = -1, need_loop_device = !!segs;
	char* mount_opts = (char*)optsarg;
	char* target = (char*)dir;
	char* fs = (char*)fsarg;
	char* source = NULL;
	char loopname[64];
	if (need_loop_device) {
		memset(loopname, 0, sizeof(loopname));
		snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
		if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
			return -1;
		source = loopname;
	}
	mkdir(target, 0777);
	char opts[256];
	memset(opts, 0, sizeof(opts));
	if (strlen(mount_opts) > (sizeof(opts) - 32)) {
	}
	strncpy(opts, mount_opts, sizeof(opts) - 32);
	if (strcmp(fs, "iso9660") == 0) {
		flags |= MS_RDONLY;
	} else if (strncmp(fs, "ext", 3) == 0) {
		if (strstr(opts, "errors=panic") || strstr(opts, "errors=remount-ro") == 0)
			strcat(opts, ",errors=continue");
	} else if (strcmp(fs, "xfs") == 0) {
		strcat(opts, ",nouuid");
	}
	res = mount(source, target, fs, flags, opts);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	res = open(target, O_RDONLY | O_DIRECTORY);
	if (res == -1) {
		err = errno;
		goto error_clear_loop;
	}
	if (change_dir) {
		res = chdir(target);
		if (res == -1) {
			err = errno;
		}
	}

error_clear_loop:
	if (need_loop_device) {
		ioctl(loopfd, LOOP_CLR_FD, 0);
		close(loopfd);
		close(memfd);
	}
	errno = err;
	return res;
}

uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
*(uint16_t*)0x20000600 = 4;
*(uint16_t*)0x20000602 = 0x1000;
*(uint16_t*)0x20000604 = 0x1800;
*(uint16_t*)0x20000606 = 0;
*(uint16_t*)0x20000608 = 0xb2a;
*(uint16_t*)0x2000060a = 0x1c00;
*(uint16_t*)0x2000060c = 1;
*(uint16_t*)0x2000060e = 8;
*(uint16_t*)0x20000610 = 0x1000;
*(uint16_t*)0x20000612 = 0;
*(uint16_t*)0x20000614 = 0xfae6;
*(uint16_t*)0x20000616 = 0x800;
	syscall(__NR_semop, -1, 0x20000600ul, 4ul);
memcpy((void*)0x20000000, "vfat\000", 5);
memcpy((void*)0x20000100, "./file0\000", 8);
*(uint64_t*)0x20000200 = 0x200000c0;
memcpy((void*)0x200000c0, "\x60\x1c\x6d\x6b\x64\x6f\x73\x66\xee\x57\x84\x00\x08\x08\x20\x00\x02\x00\x00\x80\x00\xf8\x00\x00\x20\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01", 37);
*(uint64_t*)0x20000208 = 0x25;
*(uint64_t*)0x20000210 = 0;
memcpy((void*)0x20000180, "dmask", 5);
*(uint8_t*)0x20000185 = 0x3d;
sprintf((char*)0x20000186, "%023llo", (long long)0);
*(uint8_t*)0x2000019d = 0x2c;
*(uint8_t*)0x2000019e = 0;
	res = -1;
res = syz_mount_image(0x20000000, 0x20000100, 0x25, 1, 0x20000200, 0, 0x20000180, 0);
	if (res != -1)
		r[0] = res;
memcpy((void*)0x20000000, "mountinfo\000", 10);
	res = -1;
res = syz_open_procfs(-1, 0x20000000);
	if (res != -1)
		r[1] = res;
	syscall(__NR_read, r[1], 0x20000140ul, 0xfffffdf3ul);
memcpy((void*)0x20000580, "vfat\000", 5);
memcpy((void*)0x200005c0, "./file1\000", 8);
	syscall(__NR_fsconfig, r[1], 4ul, 0x20000580ul, 0x200005c0ul, r[0]);
memcpy((void*)0x20000500, "./file0\000", 8);
memcpy((void*)0x20000540, "./file0\000", 8);
	syscall(__NR_pivot_root, 0x20000500ul, 0x20000540ul);
memcpy((void*)0x20000040, "vfat\000", 5);
memcpy((void*)0x20000080, "./file0\000", 8);
*(uint64_t*)0x20000480 = 0x20000400;
memset((void*)0x20000400, 235, 1);
*(uint64_t*)0x20000488 = 1;
*(uint64_t*)0x20000490 = 0;
*(uint64_t*)0x20000498 = 0x20000300;
memcpy((void*)0x20000300, "\x33\xe8\x20\x52", 4);
*(uint64_t*)0x200004a0 = 4;
*(uint64_t*)0x200004a8 = 1;
*(uint64_t*)0x200004b0 = 0x20000240;
memcpy((void*)0x20000240, "\x8f\x27\x10\x67\x4b\xb5\x31\xf3\xdc\xc5\xb8\x71\x45\x49\xde\xf3\x6b\x15\xad\x75\x42\x14\x8b\x61\x1f\x2c\xea\x80\x62\xd3\xac\xeb\xa4\xaf\x51\x71\xd8\x65\x0f\x8c\x6d\xec\xe7\x08\xb8\x22\xd8\x6c\xc4\x53\x71\xe2\xa3\x9e\x68\xdd\xab\x07\xfb\x65\x31\xa8\x0f\x34\x46\x50\x9b\x66\x7c\x43\x0f\x85\xb9\x51\xcc\x6d\x10\xb7\xb2\x33\xe9\x58\xe4\x4c\x91\x11\x68\xbd\xd5\xfa\xcf\xcf\xd6\x2a\x62\x8b\x04\x23\xe0\x33\xc0\xc6\xc5\x1f\x6e\x8f\x27\xa7\xd5\x2b\x25\xcd\xac\x32\x78\x82\xba\x13\x8f\x70\x97\x1b\x75\xca\x95\x34\xff\xbc\x81\xca\x21\xf4\x8c\x9e\x90\xac\xba\x25\xee\xa6\x04\xe8\x19\xac\xc5\x22\x96\x3b\xef\x12\x6a\x45\xd8\x74\xeb\xad\x57\xeb\x7b\x0a\x33", 161);
*(uint64_t*)0x200004b8 = 0xa1;
*(uint64_t*)0x200004c0 = 5;
memcpy((void*)0x20000700, "utf8=0,shortname=lower,shortname=win95,rodir,shortname=winnt,smackfsroot={,fowner=", 82);
sprintf((char*)0x20000752, "%020llu", (long long)0xee01);
memcpy((void*)0x20000766, "\x2c\x73\x6d\x61\x63\x6b\x66\x73\x66\x6c\x6f\x6f\x72\x3d\x27\x00\x80\x59\xcf\x37\xeb\x81\x22\xe0\x81\x2a\x0d\xb0\x05\x38\x11\x80\x2d\x5c\xe7\x29\x3d\xc1\x2f\x77\x5c\x72\x2d\xc5\x89\xa3\x71\xd1\x0d\xa6\xa0\xc7\xbd\x02\x7c\xa1\x24\x2f\x56\xba\x78\x62\x97\x05\xa2\x9e\x37\x1a\x09\x30\xf7\x70\x72\x0f\x30\x2c\x83\x32\x2a\xdf\x14\x02\x12\xcc\x96\x28\x8b\xb8\x15\x63\x88\x0b\x84\xd7\x67\xb9\xd7\x41\x1c\xe8\x92\x14\x98\x77\xb8\x57\x65\xa7\x15\xed\xd4\x54\xf2\xe4\xc1\x37\x8c\x79\xae\x97\xe9\xbc\x79\x0a\x7e\x0a\x4f\xf5\x97\xd7\x28\xed\x3d\xd8\x5c\xfe\x4c\xe6\xef\x0e\xaa\x86\xde\xca\x2c\x73\x6d\x61\x63\x6b\x66\x73\x64\x65\x66\x3d\x76\x66\x61\x74\x00\x2c\x00\xb9\x92\x65\x2e\xa7\x9e\x64\x41\x18\x7a\xe4\xe1\x9d\x9f\xfa\xef\x0a\x99\xfa\xae\xb8\x6b\xea\x7c\xc0\xef\x05\xd0\x83\x02\x04\x6b\xf9\x3d\x6e\x93\x3c\xd9\x21\x50\x36", 204);
syz_mount_image(0x20000040, 0x20000080, 0xcc, 3, 0x20000480, 0x86010, 0x20000700, 0);
	return 0;
}
