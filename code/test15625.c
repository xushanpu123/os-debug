// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sched.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_link.h>
#include <linux/in6.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>

#ifndef __NR_io_uring_setup
#define __NR_io_uring_setup 425
#endif
#ifndef __NR_mount_setattr
#define __NR_mount_setattr 442
#endif

struct nlmsg {
	char* pos;
	int nesting;
	struct nlattr* nested[8];
	char buf[4096];
};

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
			 const void* data, int size)
{
	memset(nlmsg, 0, sizeof(*nlmsg));
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_type = typ;
	hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
	memcpy(hdr + 1, data, size);
	nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ,
			 const void* data, int size)
{
	struct nlattr* attr = (struct nlattr*)nlmsg->pos;
	attr->nla_len = sizeof(*attr) + size;
	attr->nla_type = typ;
	if (size > 0)
		memcpy(attr + 1, data, size);
	nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock,
			    uint16_t reply_type, int* reply_len, bool dofail)
{
	if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
	exit(1);
	struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
	hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;
	struct sockaddr_nl addr;
	memset(&addr, 0, sizeof(addr));
	addr.nl_family = AF_NETLINK;
	ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));
	if (n != (ssize_t)hdr->nlmsg_len) {
		if (dofail)
	exit(1);
		return -1;
	}
	n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	if (reply_len)
		*reply_len = 0;
	if (n < 0) {
		if (dofail)
	exit(1);
		return -1;
	}
	if (n < (ssize_t)sizeof(struct nlmsghdr)) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type == NLMSG_DONE)
		return 0;
	if (reply_len && hdr->nlmsg_type == reply_type) {
		*reply_len = n;
		return 0;
	}
	if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	if (hdr->nlmsg_type != NLMSG_ERROR) {
		errno = EINVAL;
		if (dofail)
	exit(1);
		return -1;
	}
	errno = -((struct nlmsgerr*)(hdr + 1))->error;
	return -errno;
}

static int netlink_query_family_id(struct nlmsg* nlmsg, int sock, const char* family_name, bool dofail)
{
	struct genlmsghdr genlhdr;
	memset(&genlhdr, 0, sizeof(genlhdr));
	genlhdr.cmd = CTRL_CMD_GETFAMILY;
	netlink_init(nlmsg, GENL_ID_CTRL, 0, &genlhdr, sizeof(genlhdr));
	netlink_attr(nlmsg, CTRL_ATTR_FAMILY_NAME, family_name, strnlen(family_name, GENL_NAMSIZ - 1) + 1);
	int n = 0;
	int err = netlink_send_ext(nlmsg, sock, GENL_ID_CTRL, &n, dofail);
	if (err < 0) {
		return -1;
	}
	uint16_t id = 0;
	struct nlattr* attr = (struct nlattr*)(nlmsg->buf + NLMSG_HDRLEN + NLMSG_ALIGN(sizeof(genlhdr)));
	for (; (char*)attr < nlmsg->buf + n; attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
		if (attr->nla_type == CTRL_ATTR_FAMILY_ID) {
			id = *(uint16_t*)(attr + 1);
			break;
		}
	}
	if (!id) {
		errno = EINVAL;
		return -1;
	}
	recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
	return id;
}

#define SIZEOF_IO_URING_SQE 64
#define SIZEOF_IO_URING_CQE 16
#define SQ_HEAD_OFFSET 0
#define SQ_TAIL_OFFSET 64
#define SQ_RING_MASK_OFFSET 256
#define SQ_RING_ENTRIES_OFFSET 264
#define SQ_FLAGS_OFFSET 276
#define SQ_DROPPED_OFFSET 272
#define CQ_HEAD_OFFSET 128
#define CQ_TAIL_OFFSET 192
#define CQ_RING_MASK_OFFSET 260
#define CQ_RING_ENTRIES_OFFSET 268
#define CQ_RING_OVERFLOW_OFFSET 284
#define CQ_FLAGS_OFFSET 280
#define CQ_CQES_OFFSET 320

struct io_sqring_offsets {
	uint32_t head;
	uint32_t tail;
	uint32_t ring_mask;
	uint32_t ring_entries;
	uint32_t flags;
	uint32_t dropped;
	uint32_t array;
	uint32_t resv1;
	uint64_t resv2;
};

struct io_cqring_offsets {
	uint32_t head;
	uint32_t tail;
	uint32_t ring_mask;
	uint32_t ring_entries;
	uint32_t overflow;
	uint32_t cqes;
	uint64_t resv[2];
};

struct io_uring_params {
	uint32_t sq_entries;
	uint32_t cq_entries;
	uint32_t flags;
	uint32_t sq_thread_cpu;
	uint32_t sq_thread_idle;
	uint32_t features;
	uint32_t resv[4];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

#define IORING_OFF_SQ_RING 0
#define IORING_OFF_SQES 0x10000000ULL

static long syz_io_uring_setup(volatile long a0, volatile long a1, volatile long a2, volatile long a3, volatile long a4, volatile long a5)
{
	uint32_t entries = (uint32_t)a0;
	struct io_uring_params* setup_params = (struct io_uring_params*)a1;
	void* vma1 = (void*)a2;
	void* vma2 = (void*)a3;
	void** ring_ptr_out = (void**)a4;
	void** sqes_ptr_out = (void**)a5;
	uint32_t fd_io_uring = syscall(__NR_io_uring_setup, entries, setup_params);
	uint32_t sq_ring_sz = setup_params->sq_off.array + setup_params->sq_entries * sizeof(uint32_t);
	uint32_t cq_ring_sz = setup_params->cq_off.cqes + setup_params->cq_entries * SIZEOF_IO_URING_CQE;
	uint32_t ring_sz = sq_ring_sz > cq_ring_sz ? sq_ring_sz : cq_ring_sz;
	*ring_ptr_out = mmap(vma1, ring_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE | MAP_FIXED, fd_io_uring, IORING_OFF_SQ_RING);
	uint32_t sqes_sz = setup_params->sq_entries * SIZEOF_IO_URING_SQE;
	*sqes_ptr_out = mmap(vma2, sqes_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE | MAP_FIXED, fd_io_uring, IORING_OFF_SQES);
	return fd_io_uring;
}

static long syz_genetlink_get_family_id(volatile long name, volatile long sock_arg)
{
	int fd = sock_arg;
	if (fd < 0) {
		fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
		if (fd == -1) {
			return -1;
		}
	}
	struct nlmsg nlmsg_tmp;
	int ret = netlink_query_family_id(&nlmsg_tmp, fd, (char*)name, false);
	if ((int)sock_arg < 0)
		close(fd);
	if (ret < 0) {
		return -1;
	}
	return ret;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

uint64_t r[2] = {0x0, 0xffffffffffffffff};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
memcpy((void*)0x200002c0, "devlink\000", 8);
	res = -1;
res = syz_genetlink_get_family_id(0x200002c0, -1);
	if (res != -1)
		r[0] = res;
*(uint64_t*)0x20000580 = 0x20000280;
*(uint16_t*)0x20000280 = 0x10;
*(uint16_t*)0x20000282 = 0;
*(uint32_t*)0x20000284 = 0;
*(uint32_t*)0x20000288 = 0x40000;
*(uint32_t*)0x20000588 = 0xc;
*(uint64_t*)0x20000590 = 0x20000540;
*(uint64_t*)0x20000540 = 0x20000300;
*(uint32_t*)0x20000300 = 0x224;
*(uint16_t*)0x20000304 = r[0];
*(uint16_t*)0x20000306 = 0x400;
*(uint32_t*)0x20000308 = 0x70bd2d;
*(uint32_t*)0x2000030c = 0x25dfdbff;
*(uint8_t*)0x20000310 = 0x3e;
*(uint8_t*)0x20000311 = 0;
*(uint16_t*)0x20000312 = 0;
*(uint16_t*)0x20000314 = 8;
*(uint16_t*)0x20000316 = 1;
memcpy((void*)0x20000318, "pci\000", 4);
*(uint16_t*)0x2000031c = 0x11;
*(uint16_t*)0x2000031e = 2;
memcpy((void*)0x20000320, "0000:00:10.0\000", 13);
*(uint16_t*)0x20000330 = 0x1c;
*(uint16_t*)0x20000332 = 0x82;
memcpy((void*)0x20000334, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x2000034c = 5;
*(uint16_t*)0x2000034e = 0x83;
*(uint8_t*)0x20000350 = 1;
*(uint16_t*)0x20000354 = 8;
*(uint16_t*)0x20000356 = 1;
memcpy((void*)0x20000358, "pci\000", 4);
*(uint16_t*)0x2000035c = 0x11;
*(uint16_t*)0x2000035e = 2;
memcpy((void*)0x20000360, "0000:00:10.0\000", 13);
*(uint16_t*)0x20000370 = 0x1c;
*(uint16_t*)0x20000372 = 0x82;
memcpy((void*)0x20000374, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x2000038c = 5;
*(uint16_t*)0x2000038e = 0x83;
*(uint8_t*)0x20000390 = 1;
*(uint16_t*)0x20000394 = 0xe;
*(uint16_t*)0x20000396 = 1;
memcpy((void*)0x20000398, "netdevsim\000", 10);
*(uint16_t*)0x200003a4 = 0xf;
*(uint16_t*)0x200003a6 = 2;
memcpy((void*)0x200003a8, "netdevsim", 9);
*(uint8_t*)0x200003b1 = 0x30;
*(uint8_t*)0x200003b2 = 0;
*(uint16_t*)0x200003b4 = 0x1c;
*(uint16_t*)0x200003b6 = 0x82;
memcpy((void*)0x200003b8, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x200003d0 = 5;
*(uint16_t*)0x200003d2 = 0x83;
*(uint8_t*)0x200003d4 = 1;
*(uint16_t*)0x200003d8 = 8;
*(uint16_t*)0x200003da = 1;
memcpy((void*)0x200003dc, "pci\000", 4);
*(uint16_t*)0x200003e0 = 0x11;
*(uint16_t*)0x200003e2 = 2;
memcpy((void*)0x200003e4, "0000:00:10.0\000", 13);
*(uint16_t*)0x200003f4 = 0x1c;
*(uint16_t*)0x200003f6 = 0x82;
memcpy((void*)0x200003f8, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x20000410 = 5;
*(uint16_t*)0x20000412 = 0x83;
*(uint8_t*)0x20000414 = 0;
*(uint16_t*)0x20000418 = 0xe;
*(uint16_t*)0x2000041a = 1;
memcpy((void*)0x2000041c, "netdevsim\000", 10);
*(uint16_t*)0x20000428 = 0xf;
*(uint16_t*)0x2000042a = 2;
memcpy((void*)0x2000042c, "netdevsim", 9);
*(uint8_t*)0x20000435 = 0x30;
*(uint8_t*)0x20000436 = 0;
*(uint16_t*)0x20000438 = 0x1c;
*(uint16_t*)0x2000043a = 0x82;
memcpy((void*)0x2000043c, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x20000454 = 5;
*(uint16_t*)0x20000456 = 0x83;
*(uint8_t*)0x20000458 = 1;
*(uint16_t*)0x2000045c = 8;
*(uint16_t*)0x2000045e = 1;
memcpy((void*)0x20000460, "pci\000", 4);
*(uint16_t*)0x20000464 = 0x11;
*(uint16_t*)0x20000466 = 2;
memcpy((void*)0x20000468, "0000:00:10.0\000", 13);
*(uint16_t*)0x20000478 = 0x1c;
*(uint16_t*)0x2000047a = 0x82;
memcpy((void*)0x2000047c, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x20000494 = 5;
*(uint16_t*)0x20000496 = 0x83;
*(uint8_t*)0x20000498 = 1;
*(uint16_t*)0x2000049c = 0xe;
*(uint16_t*)0x2000049e = 1;
memcpy((void*)0x200004a0, "netdevsim\000", 10);
*(uint16_t*)0x200004ac = 0xf;
*(uint16_t*)0x200004ae = 2;
memcpy((void*)0x200004b0, "netdevsim", 9);
*(uint8_t*)0x200004b9 = 0x30;
*(uint8_t*)0x200004ba = 0;
*(uint16_t*)0x200004bc = 0x1c;
*(uint16_t*)0x200004be = 0x82;
memcpy((void*)0x200004c0, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x200004d8 = 5;
*(uint16_t*)0x200004da = 0x83;
*(uint8_t*)0x200004dc = 0;
*(uint16_t*)0x200004e0 = 0xe;
*(uint16_t*)0x200004e2 = 1;
memcpy((void*)0x200004e4, "netdevsim\000", 10);
*(uint16_t*)0x200004f0 = 0xf;
*(uint16_t*)0x200004f2 = 2;
memcpy((void*)0x200004f4, "netdevsim", 9);
*(uint8_t*)0x200004fd = 0x30;
*(uint8_t*)0x200004fe = 0;
*(uint16_t*)0x20000500 = 0x1c;
*(uint16_t*)0x20000502 = 0x82;
memcpy((void*)0x20000504, "source_mac_is_multicast\000", 24);
*(uint16_t*)0x2000051c = 5;
*(uint16_t*)0x2000051e = 0x83;
*(uint8_t*)0x20000520 = 0;
*(uint64_t*)0x20000548 = 0x224;
*(uint64_t*)0x20000598 = 1;
*(uint64_t*)0x200005a0 = 0;
*(uint64_t*)0x200005a8 = 0;
*(uint32_t*)0x200005b0 = 1;
	syscall(__NR_sendmsg, -1, 0x20000580ul, 0x10ul);
memcpy((void*)0x20000100, "/dev/vcsa\000", 10);
	res = syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000100ul, 0x400ul, 0ul);
	if (res != -1)
		r[1] = res;
memcpy((void*)0x20000140, "./file0\000", 8);
*(uint64_t*)0x20000180 = 0x100000;
*(uint64_t*)0x20000188 = 9;
*(uint64_t*)0x20000190 = 0xc0000;
*(uint32_t*)0x20000198 = -1;
	syscall(__NR_mount_setattr, r[1], 0x20000140ul, 0x8800ul, 0x20000180ul, 0x20ul);
memcpy((void*)0x200001c0, "./file0\000", 8);
*(uint64_t*)0x20000200 = 0x100000;
*(uint64_t*)0x20000208 = 6;
*(uint64_t*)0x20000210 = 0;
*(uint32_t*)0x20000218 = -1;
	syscall(__NR_mount_setattr, r[1], 0x200001c0ul, 0ul, 0x20000200ul, 0x20ul);
	syscall(__NR_setsockopt, -1, 0x10e, 2, 0ul, 0ul);
	syscall(__NR_pipe2, 0x20000000ul, 0x80ul);
syz_io_uring_setup(0x6751, 0, 0x20ffc000, 0x20ffe000, 0x20000040, 0x20000240);
memcpy((void*)0x20000800, "/dev/vcsa\000", 10);
	syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000800ul, 0ul, 0ul);
memcpy((void*)0x200005c0, "\xce\x6c\xb8\x15\x9f\x80\x8c\x89\x8c\xa8\x61\x14\x76\x25\xf8\xfd\xc7\x06\xb4\x56\xfc\x05\x84\x89\xa2\xc2\x93\x42\x4c\x27\x30\x59\x2f\x93\x05\x7f\xb8\xaf\x47\x2a\x9e\x92\x4a\x94\xa1\xf1\x75\x9b\xeb\x11\x87\xab\xf8\xb7\x7c\x08\x70\x89\x26\x43\xc8\x81\x68\x0a\xf0\x08\x9e\x17\x86\xe6\x57\xa7\xf9\xb1\xcb\xfc\x3b\x11\x40\x57\x9f\x19\x9d\xe7\xb2\x27\x7f\x5a\x4f\x68\x35\x37\x74\xe3\x6f\x8f\x0e\xb7\xbe\x57\x0b\xcd\xb2\x3c\x1c\x31\x46\xb2\xe0\x08\xb0\x00\xcb\x13\x32\xf7\xb1\xcc\xaa\x9a\x27\x82\x60\x59\xd2\xb5\x0d\xa8\x93\x1e\xf5\x42\x31\x11\xe9\x5e\x91\x26\x31\xfe\x24\x34\x28\x0c\x4d\xbe\x84\xc6\x42\x2f\x23\x78\xe2\xad\xa6\x53\x60\xa1\x7b\x2e\x51\xcb\x96\x74\x03\xf9\x3f\xce\xcf\x20\x86\x4c\xf4\x0e\x7a\x7a\xba\x24\x8a\xc6\x54\xf2\xc2\x29\xa7\x2c\xe5\x05\xbb\xec\x7b\xfe\xa3\xf3\x68\x9b\xaa\x67\x91\xeb\x43\x35\xcc", 203);
memcpy((void*)0x20000840, "\xbf\x3d\x42\x7f\x7e\xfa\xb0\x79\x38\x88\x94\x81\x05\xcc\xae\x2b\x62\x65\x91\x58\xed\x7e\x8c\xc1\x7e\x8b\x8c\x57\x28\xfa\x4d\x6a\x05\x40\x78\xf2\x49\x76\x29\x24\x3d\x88\x14\x45\x51\x8e\x35\x62\x08\xd7\xe5\x6a\x55\x48\xed\xe8\x6d\x83\x3b\xcf\x19\xb1\xe5\x5e\x88\x65\xac\xa2\x69\x92\xd3\xb1\x9a\x3e\xb1\x56\x50\x91\x2d\xbd\x07\x34\xbf\x2a\x44\x7a\x69\x75\xb4\xc4\x96\x01\xd5\x55\x2c\x17\x4c\x96\xf1\xbe\x88\xce\x02\x6d\x0a\x8a\xbd\xc1\x8f\x1f\x1b\x19\xe0\x16\x3c\x24\x26\x38\x92\xa9\xf9\x24\xde\x49\xf9\x52\xab\xb9\xc4\x37\x6a\x5b\x2d\x3a\xe2\x02\x25\x82\xea\xe3\xdd\x68\x84\x71\x6b\x58\x49\x50\xb5\xb5\xfc\xd2\x7c\xde\x26\xac\xeb\xb7\x27\xc8\x23\xd8\xcd\x6c\xb8\x04\x7c\xdb\x52\x24\x81\xef\xb1\x99\x07\x1a\x5c\xd9\x91\x81\x5e\x86\x14\x7b\x15\x2c\xf7\xc9\x20\x04\xd2\xcd\x72\x9f\x56\x00\x25\x8e\xe6\x79\xe1\xc2\xa8\xac\x3f\x7d\xbe\x63\x09\x91\x94\x04\xd2\x3c\x13\xcf\x12\xcf\x32\xfa\xcf\x6a\x1e\x40\x65\xf3\x68\xeb\x40\x69\x82\x07\x98\x99", 234);
syz_clone(0x40000400, 0x200005c0, 0xcb, 0x200006c0, 0x20000700, 0x20000840);
	syscall(__NR_munmap, 0x20fff000ul, 0x1000ul);
	return 0;
}
