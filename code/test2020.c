// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/sched.h>

#ifndef __NR_clone3
#define __NR_clone3 435
#endif
#ifndef __NR_pidfd_getfd
#define __NR_pidfd_getfd 438
#endif

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

#define MAX_CLONE_ARGS_BYTES 256
static long syz_clone3(volatile long a0, volatile long a1)
{
	unsigned long copy_size = a1;
	if (copy_size < sizeof(uint64_t) || copy_size > MAX_CLONE_ARGS_BYTES)
		return -1;
	char clone_args[MAX_CLONE_ARGS_BYTES];
	memcpy(&clone_args, (void*)a0, copy_size);
	uint64_t* flags = (uint64_t*)&clone_args;
	*flags &= ~CLONE_VM;
	return handle_clone_ret((long)syscall(__NR_clone3, &clone_args, copy_size));
}

uint64_t r[8] = {0x0, 0xffffffffffffffff, 0x0, 0x0, 0xffffffffffffffff, 0xffffffffffffffff, 0x0, 0x0};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
*(uint64_t*)0x20000200 = 0;
*(uint64_t*)0x20000208 = 0x20000000;
*(uint64_t*)0x20000210 = 0;
*(uint64_t*)0x20000218 = 0;
*(uint32_t*)0x20000220 = 0;
*(uint64_t*)0x20000228 = 0;
*(uint64_t*)0x20000230 = 0;
*(uint64_t*)0x20000238 = 0;
*(uint64_t*)0x20000240 = 0;
*(uint64_t*)0x20000248 = 0;
*(uint32_t*)0x20000250 = -1;
	res = -1;
res = syz_clone3(0x20000200, 0x58);
	if (res != -1) {
		r[0] = res;
r[1] = *(uint32_t*)0x20000000;
	}
*(uint64_t*)0x20000200 = 0x4000;
*(uint64_t*)0x20000208 = 0x20000000;
*(uint64_t*)0x20000210 = 0x20000040;
*(uint64_t*)0x20000218 = 0x20000080;
*(uint32_t*)0x20000220 = 0x38;
*(uint64_t*)0x20000228 = 0x200000c0;
*(uint64_t*)0x20000230 = 0x2d;
*(uint64_t*)0x20000238 = 0x20000100;
*(uint64_t*)0x20000240 = 0x200001c0;
*(uint32_t*)0x200001c0 = 0;
*(uint32_t*)0x200001c4 = 0;
*(uint32_t*)0x200001c8 = -1;
*(uint32_t*)0x200001cc = 0;
*(uint32_t*)0x200001d0 = -1;
*(uint32_t*)0x200001d4 = -1;
*(uint64_t*)0x20000248 = 6;
*(uint32_t*)0x20000250 = -1;
	res = -1;
res = syz_clone3(0x20000200, 0x58);
	if (res != -1) {
		r[2] = res;
r[3] = *(uint32_t*)0x20000080;
	}
	syscall(__NR_ptrace, 4ul, r[2], 0x20000e40ul, 0);
	res = syscall(__NR_openat, 0xffffffffffffff9cul, 0ul, 0x404000ul, 0ul);
	if (res != -1)
		r[4] = res;
	res = syscall(__NR_socket, 2ul, 3ul, 2);
	if (res != -1)
		r[5] = res;
*(uint64_t*)0x20000cc0 = 0x64018080;
*(uint64_t*)0x20000cc8 = 0x20000640;
*(uint64_t*)0x20000cd0 = 0x20000680;
*(uint64_t*)0x20000cd8 = 0x200006c0;
*(uint32_t*)0x20000ce0 = 0x11;
*(uint64_t*)0x20000ce8 = 0x20000700;
*(uint64_t*)0x20000cf0 = 0x5e;
*(uint64_t*)0x20000cf8 = 0x20000c00;
*(uint64_t*)0x20000d00 = 0x20000780;
*(uint32_t*)0x20000780 = r[3];
*(uint64_t*)0x20000d08 = 1;
*(uint32_t*)0x20000d10 = r[4];
	res = -1;
res = syz_clone3(0x20000cc0, 0x58);
	if (res != -1)
		r[6] = res;
	syscall(__NR_ptrace, 1ul, r[6], 0x200007c0ul, 0);
	syscall(__NR_setsockopt, r[5], 0, 0xd2, 0ul, 0ul);
	syscall(__NR_ioctl, r[5], 0x84009422, 0x20000800ul);
*(uint64_t*)0x20000380 = 0x28810100;
*(uint64_t*)0x20000388 = 0x20000040;
*(uint64_t*)0x20000390 = 0x20000080;
*(uint64_t*)0x20000398 = 0x200000c0;
*(uint32_t*)0x200003a0 = 0x1a;
*(uint64_t*)0x200003a8 = 0x20000100;
*(uint64_t*)0x200003b0 = 0xf1;
*(uint64_t*)0x200003b8 = 0x20000280;
*(uint64_t*)0x200003c0 = 0x20000340;
*(uint32_t*)0x20000340 = -1;
*(uint32_t*)0x20000344 = r[0];
*(uint32_t*)0x20000348 = r[2];
*(uint32_t*)0x2000034c = r[0];
*(uint32_t*)0x20000350 = 0;
*(uint64_t*)0x200003c8 = 5;
*(uint32_t*)0x200003d0 = r[4];
syz_clone3(0x20000380, 0x58);
memcpy((void*)0x20000400, "\x3a\xf7\x2e\x9d\xde\x64\x76\xc3\x40\xed\x3a\x18\x49\x87\xe1\x8b\xc7\x94\xbd\x1e\x0b\xdb\xac\x01\x56\x98\x5d\x81\x66\x23\x74\x15\xd7\xf5\x48\x96\x26\x34\xcb\x33\xd7\x27\xad\x8a\x42\xd2\x12\xaa\xd9\x7c\x69\xd0\x8e\x01\x27\xae\x99\x66\xb2\x8f\xfe\x97\x83\x1e\xe4\x84\x06\xe0\x3a\x33\xf0\x33\xf3\x0d\x21\x79\xe6\xf1\x34\xd3\xb2\x4f\x2d\x61\xf7\x9b\x23\x07\x34\xf0\x1e\x2d\x96\xa4\x90\x4f\x76\x9d\x2c\xeb\xb8\x36\xd1\x59\x8d\xa7\x00\x19\xb6\x1c\x87\xdb\x34\x55\xd0\x17\x36\x87\xdd\x65\xe8\x99\x01\x69\x93\xcd\x6e\x63\x8f\xd6\x60\x89\x5c\xf4\x2f\xc4\xa4\xd9\xda\xe4\x0f\x2b\x6c\xbf\x97\xb3\x31\xf5\x20", 149);
memcpy((void*)0x20000540, "\x66\x25\xa6\x9e\xce\xa9\x34\x59\x4d\x6e\x2c\xa3\xe6\xdd\xcc\x9a\x83\x2a\x78\x7a\xb9\x3d\x45\xcd\xe2\x28\xe4\x1e\xbd\xf2\xe5\xfd\xd4\xb8\x4a\x39\x9a\x13\x46\xf8\x62\x7a\xf1\xa4\xb4\x39\x38\xd9\x5b\x2c\xcb\xfd\xc2\x94\xe4\x43\xba\x88\x4d\x2f\x2f\xd1\x5c\x70\x7c\x10\xc3\xc3\x56\x82\xe3\x60\x39\x66\xf6\x60\x2e\x5d\x1b\x40\xd0\x65\x2a\x1b\x1e\x5a\x25\xbc\x30\x54\xb7\x18\x12\x61\x1a\x9b\x2d\xda\x2b\xf0\x4f\x47\x41\xce\x01\x48\x57\x87\xbf\x83\x8f\xb1\x77\x01\xab\xff\x15\xa3\x0c\x96\x36\xb1\x3e\xeb\xcd\x46\x77\x62\x24\xad\x02\x77\xdf\x2c\x54\x37\x10\x15\xeb\x3a\xd7\xba\x37\x50\xc3\x6d\xbb\xb6\x45\x7c\x44\xb9\x1a\xb1\x08\x7b\x2a\x80\x07\x90\xb4\x2a\x70\x02\xe4", 165);
	res = -1;
res = syz_clone(0xc0008000, 0x20000400, 0x95, 0x200004c0, 0x20000500, 0x20000540);
	if (res != -1)
		r[7] = res;
*(uint64_t*)0x20000600 = 0;
*(uint32_t*)0x20000608 = 0x34;
*(uint32_t*)0x2000060c = 2;
*(uint32_t*)0x20000610 = r[7];
	syscall(__NR_mq_notify, r[4], 0x20000600ul);
	syscall(__NR_pidfd_getfd, r[1], -1, 0ul);
	return 0;
}
