// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/loop.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static unsigned long long procid;

struct fs_image_segment {
	void* data;
	uintptr_t size;
	uintptr_t offset;
};
static int setup_loop_device(long unsigned size, long unsigned nsegs, struct fs_image_segment* segs, const char* loopname, int* memfd_p, int* loopfd_p)
{
	int err = 0, loopfd = -1;
	int memfd = syscall(__NR_memfd_create, "syzkaller", 0);
	if (memfd == -1) {
		err = errno;
		goto error;
	}
	if (ftruncate(memfd, size)) {
		err = errno;
		goto error_close_memfd;
	}
	for (size_t i = 0; i < nsegs; i++) {
		if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
		}
	}
	loopfd = open(loopname, O_RDWR);
	if (loopfd == -1) {
		err = errno;
		goto error_close_memfd;
	}
	if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
		if (errno != EBUSY) {
			err = errno;
			goto error_close_loop;
		}
		ioctl(loopfd, LOOP_CLR_FD, 0);
		usleep(1000);
		if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
			err = errno;
			goto error_close_loop;
		}
	}
	*memfd_p = memfd;
	*loopfd_p = loopfd;
	return 0;

error_close_loop:
	close(loopfd);
error_close_memfd:
	close(memfd);
error:
	errno = err;
	return -1;
}

static long syz_read_part_table(volatile unsigned long size, volatile unsigned long nsegs, volatile long segments)
{
	struct fs_image_segment* segs = (struct fs_image_segment*)segments;
	int err = 0, res = -1, loopfd = -1, memfd = -1;
	char loopname[64];
	snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
	if (setup_loop_device(size, nsegs, segs, loopname, &memfd, &loopfd) == -1)
		return -1;
	struct loop_info64 info;
	if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	info.lo_flags |= LO_FLAGS_PARTSCAN;
	if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
		err = errno;
		goto error_clear_loop;
	}
	res = 0;
	for (unsigned long i = 1, j = 0; i < 8; i++) {
		snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
		struct stat statbuf;
		if (stat(loopname, &statbuf) == 0) {
			char linkname[64];
			snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
			if (symlink(loopname, linkname)) {
			}
		}
	}
error_clear_loop:
	ioctl(loopfd, LOOP_CLR_FD, 0);
	close(loopfd);
	close(memfd);
	errno = err;
	return res;
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);

*(uint64_t*)0x20000dc0 = 0x20000980;
*(uint16_t*)0x20000980 = 0x10;
*(uint16_t*)0x20000982 = 0;
*(uint32_t*)0x20000984 = 0;
*(uint32_t*)0x20000988 = 0;
*(uint32_t*)0x20000dc8 = 0xc;
*(uint64_t*)0x20000dd0 = 0x20000d80;
*(uint64_t*)0x20000d80 = 0;
*(uint64_t*)0x20000d88 = 0;
*(uint64_t*)0x20000dd8 = 1;
*(uint64_t*)0x20000de0 = 0;
*(uint64_t*)0x20000de8 = 0;
*(uint32_t*)0x20000df0 = 0;
	syscall(__NR_sendmsg, -1, 0x20000dc0ul, 0ul);
*(uint64_t*)0x200004c0 = 0x20000000;
*(uint16_t*)0x20000000 = 0x10;
*(uint16_t*)0x20000002 = 0;
*(uint32_t*)0x20000004 = 0;
*(uint32_t*)0x20000008 = 0;
*(uint32_t*)0x200004c8 = 0xc;
*(uint64_t*)0x200004d0 = 0x20000480;
*(uint64_t*)0x20000480 = 0;
*(uint64_t*)0x20000488 = 0;
*(uint64_t*)0x200004d8 = 1;
*(uint64_t*)0x200004e0 = 0;
*(uint64_t*)0x200004e8 = 0;
*(uint32_t*)0x200004f0 = 0;
	syscall(__NR_sendmsg, -1, 0x200004c0ul, 0ul);
*(uint64_t*)0x20000940 = 0x20000540;
*(uint16_t*)0x20000540 = 0x11;
*(uint16_t*)0x20000542 = htobe16(0);
*(uint32_t*)0x20000544 = 0;
*(uint16_t*)0x20000548 = 1;
*(uint8_t*)0x2000054a = 0;
*(uint8_t*)0x2000054b = 6;
*(uint8_t*)0x2000054c = 1;
*(uint8_t*)0x2000054d = 0x80;
*(uint8_t*)0x2000054e = 0xc2;
*(uint8_t*)0x2000054f = 0;
*(uint8_t*)0x20000550 = 0;
*(uint8_t*)0x20000551 = 0;
memset((void*)0x20000552, 0, 2);
*(uint32_t*)0x20000948 = 0x80;
*(uint64_t*)0x20000950 = 0x200008c0;
*(uint64_t*)0x200008c0 = 0;
*(uint64_t*)0x200008c8 = 0;
*(uint64_t*)0x200008d0 = 0;
*(uint64_t*)0x200008d8 = 0;
*(uint64_t*)0x200008e0 = 0x20000740;
memset((void*)0x20000740, 242, 1);
*(uint64_t*)0x200008e8 = 1;
*(uint64_t*)0x200008f0 = 0x20000800;
*(uint64_t*)0x200008f8 = 0;
*(uint64_t*)0x20000958 = 4;
*(uint64_t*)0x20000960 = 0;
*(uint64_t*)0x20000968 = 0;
*(uint32_t*)0x20000970 = 0;
	syscall(__NR_sendmsg, -1, 0x20000940ul, 0ul);
*(uint64_t*)0x20000040 = 0x20000080;
memcpy((void*)0x20000080, "\x84\x2b\x51\xb3\x95\xe3\x82\xff\x58\x18\x35\x1b\xc0\x77\x6f\x1c\x23\x5a\x42\x90\x95\xc3\xd2\x31\xa1\x5a\xcf\x52\x76\xa8\xa8\x9c\xaf\xe2\xde\x37\x3c\xff\x8e\xd1\x50\x58\xee\xde\xd9\x27\xaa\x02\x0a\x4a\x68\xbb\xda\xf6\xbb\x76\xd9\x55\x43\xd1\x95\x4e\x7d\x7f\x72\x36\xfa\x8e\xa4\x49\xe3\xf7\xf1\xb4\x68\xd6\x85\xd3\x48\xbe\x9d\x85\x8c\x18\xac\x68\x97\x44\xbc\x91\xcc\x9a\xa6\xc8\x55\xef\xdc\x96\xdb\x54\x3e\x5b\x08\x0e\xc3\x75\x2f\x5f\x33\x91\xc1\x2c\xbf\x3f\x46\xc8\x27\x18\x1a\xfe\x94\x63\x43\x1c\x6e\xcc\x8c\x4a\xef\xc9\x2b\xa3\x6c\x62\x6f\xd8\xc5\x09\xa9\x80\xcc\x57\xa5\x00\x8f\x53\xea\x1c\xf7\x65\x52\x5e\xb7\xff\x78\x44\xdc\xce\x63\x01\x44\x7f\x0f\x46\x63\xf2\xe2\x00\x9d\xc0\xaf\x01\xf5\xb4\xfc\x9a\xb0\x99\xdc\xe4\x09\x59\x94\xa6\x46\x9b\xeb\xe3\xf1\x7d\xbc\x6e\xbd\xea\x88\x9f\x85\x71\xf0\x6d\xf4\xb8\xbb\xfe\x8e\xf3\x13\xbc\x5f\xeb\xa9\xd8\xdb\x90\x93\x58\x06\xb2\x9a\x1c\x65\xff\xb6\x0b\x2f\xfc\x12\x9d\x27\xc7\x4b\x6f\x2f\x05\x34\x21\xba\xb2\x89\x8a\x3d\x18\x8a\xae\xfe\x87\xf2\x5d\x74\x19\xe0\x04\xba", 253);
*(uint64_t*)0x20000048 = 0xfd;
*(uint64_t*)0x20000050 = 2;
syz_read_part_table(0, 0xaaaaaaaaaaaab81, 0x20000040);
	return 0;
}
