// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <endian.h>
#include <fcntl.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

static long syz_open_procfs(volatile long a0, volatile long a1)
{
	char buf[128];
	memset(buf, 0, sizeof(buf));
	if (a0 == 0) {
		snprintf(buf, sizeof(buf), "/proc/self/%s", (char*)a1);
	} else if (a0 == -1) {
		snprintf(buf, sizeof(buf), "/proc/thread-self/%s", (char*)a1);
	} else {
		snprintf(buf, sizeof(buf), "/proc/self/task/%d/%s", (int)a0, (char*)a1);
	}
	int fd = open(buf, O_RDWR);
	if (fd == -1)
		fd = open(buf, O_RDONLY);
	return fd;
}

#define USLEEP_FORKED_CHILD (3 * 50 *1000)

static long handle_clone_ret(long ret)
{
	if (ret != 0) {
		return ret;
	}
	usleep(USLEEP_FORKED_CHILD);
	syscall(__NR_exit, 0);
	while (1) {
	}
}

static long syz_clone(volatile long flags, volatile long stack, volatile long stack_len,
		      volatile long ptid, volatile long ctid, volatile long tls)
{
	long sp = (stack + stack_len) & ~15;
	long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
	return handle_clone_ret(ret);
}

uint64_t r[3] = {0xffffffffffffffff, 0x0, 0x0};

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
	syscall(__NR_ioctl, -1, 0x127e, 0x20000000ul);
memcpy((void*)0x20000040, "net/hci\000", 8);
	res = -1;
res = syz_open_procfs(-1, 0x20000040);
	if (res != -1)
		r[0] = res;
*(uint32_t*)0x20000180 = 0xfffff801;
*(uint32_t*)0x20000184 = 7;
*(uint32_t*)0x20000188 = 0xde;
*(uint64_t*)0x20000190 = 0x20000080;
memcpy((void*)0x20000080, "\xbc\x49\x35\xe9\x3e\x87\xbc\xf3\xce\xcd\xf7\xf4\x8c\x6d\x23\x91\x56\x61\x20\x84\xfe\xb8\x93\x28\xb4\xbe\x2c\xc4\xd9\xf7\xae\x89\x4c\x35\xa8\xee\xd5\x08\x29\x68\x06\x71\x49\x4a\xc3\xd1\x44\x10\x27\x6b\xa3\x54\xe6\xc4\xda\x13\xcf\x9a\x58\x6e\x4d\xa6\xfb\x44\x69\x08\x9d\xd0\x31\xa9\x77\x61\x24\x90\xa1\x95\x8d\x97\x35\x80\x2b\x70\xf7\xae\x49\x38\x33\xef\x52\x9d\x6b\xee\x57\x29\x99\x80\x78\x38\xda\x78\xf8\xca\x8f\xdd\xa1\x23\x6b\xb0\xb3\x66\x53\x71\x95\x58\x1e\xba\x24\xd5\x15\xbb\x55\xb7\x88\x19\x44\xc4\x64\x6f\x42\xeb\xa8\xd7\x80\x75\x19\x0f\xea\x07\x8a\xa6\xab\x72\xac\x92\x09\x35\x67\x08\xbe\xc3\xd6\x05\x43\xab\xca\xb4\xd6\x18\x84\x49\x34\xcd\x8f\x31\x7e\xe3\xa8\x93\x6d\x33\x59\x1b\xe8\x1e\x96\x66\xfc\xf2\x0e\x8c\x9b\x20\x11\x8f\x6f\x3e\x67\x9f\xd1\xcf\xae\x3b\x7d\x65\x8a\x58\x78\xf8\x7c\xef\xeb\x52\xe1\x96\x5f\xbe\x8a\xc4\x86\xce\x68\x16\x3f\x9f\x48\xc6\x8c\x5d\x11\x21\x63\x38", 222);
	syscall(__NR_ioctl, r[0], 0x1269, 0x20000180ul);
*(uint32_t*)0x200001c0 = 0x18;
*(uint32_t*)0x200001c4 = 0;
STORE_BY_BITMASK(uint32_t, , 0x200001c8, 0, 0, 1);
memcpy((void*)0x200001c9, "queue0\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", 64);
*(uint32_t*)0x2000020c = 0x800;
memset((void*)0x20000210, 0, 60);
	syscall(__NR_ioctl, r[0], 0xc08c5336, 0x200001c0ul);
*(uint64_t*)0x20000280 = 0x100000000;
*(uint32_t*)0x20000288 = 0;
*(uint32_t*)0x2000028c = 0;
	syscall(__NR_ioctl, r[0], 0x401070ca, 0x20000280ul);
memset((void*)0x200002c0, 0, 64);
*(uint32_t*)0x20000300 = 0x7f;
*(uint32_t*)0x20000304 = 2;
*(uint32_t*)0x20000308 = 0;
memset((void*)0x2000030c, 0, 20);
	syscall(__NR_ioctl, r[0], 0xc0603d06, 0x200002c0ul);
*(uint32_t*)0x20000340 = 1;
*(uint32_t*)0x20000344 = 1;
*(uint32_t*)0x20000348 = 0x18;
*(uint32_t*)0x2000034c = r[0];
*(uint32_t*)0x20000350 = 0;
*(uint32_t*)0x20000354 = 0;
memcpy((void*)0x20000358, "./file0\000", 8);
	res = syscall(__NR_ioctl, r[0], 0xc018937b, 0x20000340ul);
	if (res != -1)
r[1] = *(uint32_t*)0x20000354;
memcpy((void*)0x20000380, "./file0\000", 8);
	res = syscall(__NR_newfstatat, 0xffffffffffffff9cul, 0x20000380ul, 0x200003c0ul, 0x400ul);
	if (res != -1)
r[2] = *(uint32_t*)0x200003dc;
*(uint32_t*)0x20000440 = r[1];
*(uint32_t*)0x20000444 = 0;
*(uint32_t*)0x20000448 = 0;
*(uint32_t*)0x2000044c = 0;
*(uint32_t*)0x20000450 = r[2];
*(uint32_t*)0x20000454 = -1;
*(uint32_t*)0x20000458 = -1;
	syscall(__NR_getgroups, 7ul, 0x20000440ul);
memcpy((void*)0x20000480, "/dev/cdrom\000", 11);
	syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000480ul, 0x242ul, 0ul);
syz_clone(0x2042080, 0, 0, 0x20000780, 0x200007c0, 0x20000800);
	return 0;
}
